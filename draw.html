<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Board</title>
    <meta name="description" content="DocuWrite Pro is an all-in-one online workspace that lets you write, edit, convert, design, and manage documents and digital content instantly—no installation, no complexity.">
  <meta name="keywords" content="DocuWrite Pro, Mohtadi Azad Mahi, AI writer, document editor, online text tool, GitHub project, DocuWritePro, Document Editor, Document, Editor, PDF, JPG, Edit, Text, Change File Type, File Changer, Format, Format Changer, Office, Docs, A4, Editor, General document editing, Collab, Editing documents together, Document Viewer, Viewing documents, Word Finder, Searching for specific words, Translator, Language translation, Document Signer, Electronically signing documents, Page Number Adder, Adding page numbers to documents, Chart Maker, Creating data charts, Table Maker, Creating tables, Watermark Adder, Adding watermarks to files, Email Writer, Assisting with writing emails, Spell Checker, Checking spelling and grammar, File Extractor, Extracting contents from files, QR Maker, Creating QR codes, ID Card Maker, Designing and creating ID cards, File Zipper, Compressing or zipping files, PDF Converter, Converting files to or from PDF format, Context Field, Analyzing text (e.g., word count, frequency), Gift Card Maker, Creating custom gift cards, Share File, Uploading or sharing a file, Text Extractor, Extracting text from sources (e.g., images), Keyboard Click Test, Testing keyboard functionality, Frontend IDE, Integrated Development Environment for frontend coding, HTML Editor, Editing HTML code, HTML Writer, Writing or generating HTML content, Button Designer, Designing user interface buttons, HTML Splitter, Splitting HTML files or elements, GoTo Code, Navigation feature in an IDE/editor, Code Snipper, Storing or managing code snippets, Image Editor, Editing images, Image Generator, Generating new images, Drawing Board, A simple drawing or sketching tool, HTML, CSS, JS, Online, Fast, Easy, No login, No signup, Free, No credit card required, Mohtadi, Azad, Mahi, Mohtadi Azad, Mohtadi Azad Mahi, mahi902">
  <meta name="author" content="Mohtadi Azad Mahi">
  <meta name="robots" content="index, follow">

  <!-- Favicon & App Icons -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <link rel="icon" type="image/png" sizes="192x192" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <link rel="apple-touch-icon" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <meta name="theme-color" content="#ffffff">

  <!-- App & Brand Metadata -->
  <meta property="og:site_name" content="DocuWrite Pro">
  <meta name="application-name" content="DocuWrite Pro">
  <meta name="apple-mobile-web-app-title" content="DocuWrite Pro">

  <!-- Open Graph -->
  <meta property="og:title" content="DocuWrite Pro — Online Document Editor">
  <meta property="og:description" content="Edit, format, and export documents easily with DocuWrite Pro by Mohtadi Azad Mahi.">
  <meta property="og:url" content="https://mahi902.github.io/DocuWritePro/">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">

  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="DocuWrite Pro — Online Document Editor">
  <meta name="twitter:description" content="Create, format, and export documents easily with DocuWrite Pro. Built by Mohtadi Azad Mahi.">
  <meta name="twitter:image" content="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">

  <!-- Structured Data (Google Knowledge Graph) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "DocuWrite Pro",
    "alternateName": "DocuWrite Pro — Online Document Editor",
    "url": "https://mahi902.github.io/DocuWritePro/",
    "creator": {
      "@type": "Person",
      "name": "Mohtadi Azad Mahi"
    }
  }
  </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for Google Docs light theme feel */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa; /* Light gray background */
            color: #3c4043; /* Dark gray text */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better layout */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            flex-direction: column;
            background-color: #ffffff; /* White background for the board area */
            border-radius: 8px;
            box-shadow: 0 1px 3px 0 rgba(60, 64, 67, 0.3), 0 4px 8px 3px rgba(60, 64, 67, 0.15); /* Google-like shadow */
            overflow: hidden;
            max-width: 1200px;
            width: 100%;
        }

        .header {
            background-color: #f1f3f4; /* Light header background */
            border-bottom: 1px solid #dadce0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .main-content {
            display: flex;
            flex-direction: column; /* Stack controls and canvas vertically on small screens */
            flex-grow: 1;
        }

        .controls {
            background-color: #ffffff; /* White background for controls */
            padding: 16px;
            border-right: 1px solid #dadce0; /* Separator for desktop */
            min-width: 200px;
            max-width: 250px;
            overflow-y: auto;
        }

        .canvas-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #e8eaed; /* Canvas paper background */
            overflow: auto; /* Allow scrolling if canvas is larger than view */
        }

        canvas {
            background-color: #ffffff; /* Actual canvas background */
            border: 1px solid #dadce0;
            box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.1), 0 2px 6px 2px rgba(60, 64, 67, 0.15);
            border-radius: 4px;
            /* touch-action: none; This will be controlled by JS based on lock state */
            display: block; /* Remove extra space below canvas */
            transform-origin: 0 0; /* Set transform origin for zooming */
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            margin-bottom: 8px;
            color: #5f6368; /* Darker gray for labels */
        }

        .control-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 4px;
            background: #dadce0;
            border-radius: 2px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        .control-group input[type="range"]:hover {
            opacity: 1;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1a73e8; /* Google Blue */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.2);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #1a73e8; /* Google Blue */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.2);
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #dadce0;
            border-radius: 4px;
            padding: 2px;
            cursor: pointer;
        }

        .action-button {
            @apply flex items-center justify-center p-2 rounded-full text-gray-600 hover:bg-gray-200 transition-colors duration-200 cursor-pointer;
            box-shadow: none; /* Override default button shadow */
        }

        .action-button.active {
            @apply bg-blue-100 text-blue-700;
        }

        .tool-button {
            @apply flex items-center justify-center p-2 rounded-md text-gray-600 hover:bg-gray-200 transition-colors duration-200 cursor-pointer;
            box-shadow: none;
            width: 40px; /* Fixed width for tool buttons */
            height: 40px; /* Fixed height for tool buttons */
        }

        .tool-button.active {
            @apply bg-blue-100 text-blue-700;
        }

        .paper-size-buttons .tool-button {
            width: auto; /* Allow text to dictate width */
            padding: 8px 12px;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .main-content {
                flex-direction: row; /* Controls on left, canvas on right for desktop */
            }
        }

        /* Message Box Styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 300px;
            text-align: center;
        }

        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            z-index: 999;
            display: none; /* Hidden by default */
        }

        .message-box button {
            @apply bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition-colors;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="text-xl font-medium text-gray-700">Drawing Board</h1>
            <div class="flex items-center space-x-2">
                <button id="lockBoardBtn" class="action-button" title="Lock/Unlock Board for Scrolling">
                    <span class="material-icons">lock_open</span>
                </button>
                <button id="zoomOutBtn" class="action-button" title="Zoom Out">
                    <span class="material-icons">zoom_out</span>
                </button>
                <button id="zoomInBtn" class="action-button" title="Zoom In">
                    <span class="material-icons">zoom_in</span>
                </button>
                <button id="signBtn" class="action-button" title="Sign Canvas">
                    <span class="material-icons">edit_note</span>
                </button>
                <button id="undoBtn" class="action-button" title="Undo">
                    <span class="material-icons">undo</span>
                </button>
                <button id="redoBtn" class="action-button" title="Redo">
                    <span class="material-icons">redo</span>
                </button>
                <button id="downloadBtn" class="action-button" title="Download as JPG">
                    <span class="material-icons">download</span>
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="controls">
                <div class="control-group">
                    <label for="colorPicker">Color</label>
                    <input type="color" id="colorPicker" value="#1a73e8">
                </div>

                <div class="control-group">
                    <label for="lineWidth">Line Width: <span id="lineWidthValue">5</span>px</label>
                    <input type="range" id="lineWidth" min="1" max="50" value="5">
                </div>

                <div class="control-group">
                    <label for="transparency">Transparency: <span id="transparencyValue">100</span>%</label>
                    <input type="range" id="transparency" min="0" max="100" value="100">
                </div>

                <div class="control-group">
                    <label for="glowBlur">Glow Blur: <span id="glowBlurValue">0</span>px</label>
                    <input type="range" id="glowBlur" min="0" max="50" value="0">
                </div>

                <div class="control-group">
                    <label for="glowColorPicker">Glow Color</label>
                    <input type="color" id="glowColorPicker" value="#ffffff">
                </div>

                <div class="control-group">
                    <label>Tool</label>
                    <div class="flex flex-wrap gap-2">
                        <button id="pencilTool" class="tool-button active" title="Pencil">
                            <span class="material-icons">create</span>
                        </button>
                        <button id="eraserTool" class="tool-button" title="Eraser">
                            <span class="material-icons">cleaning_services</span>
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Canvas Paper Size</label>
                    <div class="flex flex-wrap gap-2 paper-size-buttons">
                        <button class="tool-button" data-width="800" data-height="600">800x600</button>
                        <button class="tool-button" data-width="1024" data-height="768">1024x768</button>
                        <button class="tool-button" data-width="1280" data-height="720">1280x720</button>
                        <button class="tool-button" data-width="1920" data-height="1080">1920x1080</button>
                        <button class="tool-button" data-width="500" data-height="800">500x800</button>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <canvas id="drawingCanvas"></canvas>
            </div>
        </div>
    </div>

    <div id="messageBoxOverlay" class="message-box-overlay"></div>
    <div id="messageBox" class="message-box">
        <p id="messageBoxText"></p>
        <button id="messageBoxCloseBtn">OK</button>
    </div>
<script>
        // Get canvas and context
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        // Get control elements
        const colorPicker = document.getElementById('colorPicker');
        const lineWidthInput = document.getElementById('lineWidth');
        const lineWidthValueSpan = document.getElementById('lineWidthValue');
        const transparencyInput = document.getElementById('transparency');
        const transparencyValueSpan = document.getElementById('transparencyValue');
        const glowBlurInput = document.getElementById('glowBlur');
        const glowBlurValueSpan = document.getElementById('glowBlurValue');
        const glowColorPicker = document.getElementById('glowColorPicker');
        const pencilToolBtn = document.getElementById('pencilTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const paperSizeButtons = document.querySelectorAll('.paper-size-buttons .tool-button');
        const lockBoardBtn = document.getElementById('lockBoardBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const signBtn = document.getElementById('signBtn');

        // Message Box elements
        const messageBox = document.getElementById('messageBox');
        const messageBoxOverlay = document.getElementById('messageBoxOverlay');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');

        // Drawing state variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingHistory = [];
        let historyPointer = -1;
        let currentTool = 'pencil'; // 'pencil' or 'eraser'

        // Lock board state
        let isBoardLocked = false;

        // Zoom variables
        let zoomLevel = 1.0;
        const ZOOM_STEP = 0.1;
        const MAX_ZOOM = 3.0;
        const MIN_ZOOM = 0.2;

        // --- Initial Canvas Setup ---
        function initializeCanvas() {
            // Set initial canvas dimensions
            canvas.width = 1024;
            canvas.height = 768;

            // Set initial drawing properties
            ctx.strokeStyle = colorPicker.value;
            ctx.lineWidth = lineWidthInput.value;
            ctx.globalAlpha = transparencyInput.value / 100;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = glowBlurInput.value;
            ctx.shadowColor = glowColorPicker.value;
            ctx.globalCompositeOperation = 'source-over'; // Default to normal drawing mode

            // Clear canvas and save initial blank state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveState();
            updateToolButtons(); // Ensure pencil is active initially
            updateHistoryButtons();
            updateLockBoardButton(); // Initialize lock button state
            applyZoom(); // Apply initial zoom (1.0)
        }
// --- History (Undo/Redo) Functions ---
        function saveState() {
            // If we are not at the end of the history (i.e., we've undone some actions),
            // clear the "redo" history before adding a new state.
            if (historyPointer < drawingHistory.length - 1) {
                drawingHistory = drawingHistory.slice(0, historyPointer + 1);
            }
            drawingHistory.push(canvas.toDataURL()); // Save current canvas image data
            historyPointer = drawingHistory.length - 1;
            updateHistoryButtons();
        }

        function restoreState(index) {
            if (index >= 0 && index < drawingHistory.length) {
                const imageData = drawingHistory[index];
                const img = new Image();
                img.src = imageData;
                img.onload = () => {
                    // Temporarily reset transform for accurate drawing of the base image
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    ctx.restore(); // Restore previous transform (including zoom)
                };
                historyPointer = index;
                updateHistoryButtons();
            }
        }

        function undo() {
            if (historyPointer > 0) {
                restoreState(historyPointer - 1);
            } else {
                showMessage("Nothing more to undo.");
            }
        }

        function redo() {
            if (historyPointer < drawingHistory.length - 1) {
                restoreState(historyPointer + 1);
            } else {
                showMessage("Nothing more to redo.");
            }
        }

        function updateHistoryButtons() {
            undoBtn.disabled = historyPointer <= 0;
            redoBtn.disabled = historyPointer >= drawingHistory.length - 1;
            // Add/remove active class for visual feedback
            undoBtn.classList.toggle('active', !undoBtn.disabled);
            redoBtn.classList.toggle('active', !redoBtn.disabled);
        }
// --- Drawing Functions ---
        function drawLine(eventObject) {
            if (!isDrawing) return; // Stop the function if not drawing

            ctx.beginPath(); // Start a new path

            // Set drawing properties based on current tool
            if (currentTool === 'pencil') {
                ctx.globalCompositeOperation = 'source-over'; // Normal drawing mode
                ctx.strokeStyle = colorPicker.value;
                ctx.shadowBlur = glowBlurInput.value;
                ctx.shadowColor = glowColorPicker.value;
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out'; // Erase mode
                ctx.strokeStyle = 'rgba(0,0,0,1)'; // Any color, but destination-out makes it transparent
                ctx.shadowBlur = 0; // No glow for eraser
                ctx.shadowColor = 'transparent';
            }

            ctx.lineWidth = lineWidthInput.value / zoomLevel; // Adjust line width for zoom
            ctx.globalAlpha = transparencyInput.value / 100;

            // Get coordinates from mouse or touch event, adjusted for zoom
            const { x, y } = getEventCoords(eventObject);

            ctx.moveTo(lastX, lastY); // Move to the last recorded position
            ctx.lineTo(x, y); // Draw a line to the current position
            ctx.stroke(); // Apply the stroke

            // Update last coordinates for the next segment
            lastX = x;
            lastY = y;
        }

        // --- Event Handlers for Canvas Interaction ---

        // Helper to get coordinates from mouse or touch event, adjusted for zoom
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            // Adjust coordinates by current zoom level
            return {
                x: (clientX - rect.left) / zoomLevel,
                y: (clientY - rect.top) / zoomLevel
            };
        }

        function handleMouseDown(e) {
            if (isBoardLocked) return; // If board is locked, allow scrolling, not drawing
            e.preventDefault(); // Prevent default browser actions like text selection

            const { x, y } = getEventCoords(e);

            if (currentTool === 'pencil' || currentTool === 'eraser') {
                isDrawing = true;
                lastX = x;
                lastY = y;
                drawLine(e); // Draw a dot on click
            }
        }

        function handleMouseMove(e) {
            if (isBoardLocked) return;
            e.preventDefault();

            if (isDrawing) {
                drawLine(e);
            }
        }

        function handleMouseUp(e) {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            }
        }

        function handleMouseOut(e) {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            }
        }

        // Touch event handlers (mirroring mouse events)
        function handleTouchStart(e) {
            if (isBoardLocked) return;
            e.preventDefault(); // Prevent scrolling

            const { x, y } = getEventCoords(e);

            if (currentTool === 'pencil' || currentTool === 'eraser') {
                isDrawing = true;
                lastX = x;
                lastY = y;
                drawLine(e.touches[0]); // Pass touch object
            }
        }

        function handleTouchMove(e) {
            if (isBoardLocked) return;
            e.preventDefault(); // Prevent scrolling

            if (isDrawing) {
                drawLine(e.touches[0]);
            }
        }

        function handleTouchEnd(e) {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            }
        }

        function handleTouchCancel(e) {
            if (isDrawing) {
                isDrawing = false;
                saveState();
            }
        }

        // Attach event listeners to canvas
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseout', handleMouseOut);

        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchCancel);
// --- Control Panel Event Listeners ---

        colorPicker.addEventListener('input', (e) => {
            ctx.strokeStyle = e.target.value;
        });

        lineWidthInput.addEventListener('input', (e) => {
            ctx.lineWidth = e.target.value / zoomLevel; // Adjust for zoom
            lineWidthValueSpan.textContent = e.target.value;
        });

        transparencyInput.addEventListener('input', (e) => {
            ctx.globalAlpha = e.target.value / 100;
        });

        glowBlurInput.addEventListener('input', (e) => {
            ctx.shadowBlur = e.target.value;
            glowBlurValueSpan.textContent = e.target.value;
            // If glow blur is set, ensure glow color is not transparent for pencil tool
            if (currentTool === 'pencil' && e.target.value > 0 && ctx.shadowColor === 'transparent') {
                ctx.shadowColor = glowColorPicker.value;
            }
        });

        glowColorPicker.addEventListener('input', (e) => {
            ctx.shadowColor = e.target.value;
        });

        // Tool selection
        function updateToolButtons() {
            const allToolButtons = document.querySelectorAll('.tool-button');
            allToolButtons.forEach(btn => btn.classList.remove('active'));

            switch (currentTool) {
                case 'pencil':
                    pencilToolBtn.classList.add('active');
                    break;
                case 'eraser':
                    eraserToolBtn.classList.add('active');
                    break;
                default:
                    break;
            }
        }

        pencilToolBtn.addEventListener('click', () => {
            currentTool = 'pencil';
            updateToolButtons();
            // Restore glow settings when switching back to pencil
            ctx.shadowBlur = glowBlurInput.value;
            ctx.shadowColor = glowColorPicker.value;
            ctx.globalCompositeOperation = 'source-over'; // Ensure normal drawing
        });

        eraserToolBtn.addEventListener('click', () => {
            currentTool = 'eraser';
            updateToolButtons();
            // Eraser-specific settings
            ctx.shadowBlur = 0; // No glow for eraser
            ctx.shadowColor = 'transparent'; // No glow for eraser
            ctx.globalCompositeOperation = 'destination-out'; // Erase mode
        });

        // Undo/Redo buttons
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        // Download button
        downloadBtn.addEventListener('click', () => {
            showDownloadPrompt();
        });

        function showDownloadPrompt() {
            messageBoxText.innerHTML = `
                <p class="text-lg font-medium mb-3">Download Drawing</p>
                <input type="text" id="filenameInput" placeholder="Enter filename (e.g., my_drawing)" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400 mb-4">
                <div class="flex justify-end w-full space-x-2">
                    <button id="cancelDownloadBtn" class="bg-gray-200 text-gray-700 hover:bg-gray-300 px-4 py-2 rounded-md">Cancel</button>
                    <button id="confirmDownloadBtn" class="bg-blue-500 text-white hover:bg-blue-600 px-4 py-2 rounded-md">Download</button>
                </div>
            `;
            messageBox.style.display = 'flex';
            messageBoxOverlay.style.display = 'block';

            const filenameInput = document.getElementById('filenameInput');
            const cancelDownloadBtn = document.getElementById('cancelDownloadBtn');
            const confirmDownloadBtn = document.getElementById('confirmDownloadBtn');

            // Focus on input field
            setTimeout(() => filenameInput.focus(), 100);

            // Event listeners for the download prompt
            confirmDownloadBtn.onclick = () => {
                const filename = filenameInput.value.trim() || 'drawing_board';
                performDownload(filename);
                hideMessageBox();
            };

            cancelDownloadBtn.onclick = hideMessageBox;

            // Allow pressing Enter to confirm download
            filenameInput.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    confirmDownloadBtn.click();
                }
            };
        }

        function performDownload(filename) {
            // Create a temporary canvas with a white background to ensure JPG looks good
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Fill with white background
            tempCtx.fillStyle = '#FFFFFF';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw the current canvas content onto the temporary canvas
            // IMPORTANT: Temporarily reset canvas transform for accurate drawing to temp canvas
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset zoom for drawing to temp canvas
            tempCtx.drawImage(canvas, 0, 0);
            ctx.restore(); // Restore original zoom level

            // Get data URL from the temporary canvas
            const image = tempCanvas.toDataURL('image/jpeg', 0.9); // 0.9 quality for JPG

            const link = document.createElement('a');
            link.href = image;
            link.download = `${filename}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage(`Image downloaded as ${filename}.jpg!`);
        }
// Canvas paper size buttons
        paperSizeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const newWidth = parseInt(e.target.dataset.width);
                const newHeight = parseInt(e.target.dataset.height);

                drawingHistory = [];
                historyPointer = -1;

                canvas.width = newWidth;
                canvas.height = newHeight;

                // Re-initialize context properties after canvas resize
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = lineWidthInput.value / zoomLevel;
                ctx.globalAlpha = transparencyInput.value / 100;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = glowBlurInput.value; // Glow blur is not scaled by zoom
                ctx.shadowColor = glowColorPicker.value;
                ctx.globalCompositeOperation = currentTool === 'pencil' ? 'source-over' : 'destination-out';

                // Apply current zoom after resizing canvas
                applyZoom();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveState(); // Save the new blank state
                showMessage(`Canvas resized to ${newWidth}x${newHeight}. History cleared.`);
            });
        });

        // Lock/Unlock Board Button
        lockBoardBtn.addEventListener('click', () => {
            isBoardLocked = !isBoardLocked;
            updateLockBoardButton();
            showMessage(`Drawing board ${isBoardLocked ? 'locked' : 'unlocked'} for scrolling.`);
        });

        function updateLockBoardButton() {
            lockBoardBtn.classList.toggle('active', isBoardLocked);
            lockBoardBtn.querySelector('.material-icons').textContent = isBoardLocked ? 'lock' : 'lock_open';
            // Control touch-action to allow/prevent default scrolling on canvas
            canvas.style.touchAction = isBoardLocked ? 'auto' : 'none';
        }

        // --- Zoom Functions ---
        zoomInBtn.addEventListener('click', () => {
            if (zoomLevel < MAX_ZOOM) {
                zoomLevel = Math.min(MAX_ZOOM, zoomLevel + ZOOM_STEP);
                applyZoom();
                redrawCanvasFromHistory();
                showMessage(`Zoom: ${Math.round(zoomLevel * 100)}%`);
            } else {
                showMessage("Maximum zoom reached.");
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (zoomLevel > MIN_ZOOM) {
                zoomLevel = Math.max(MIN_ZOOM, zoomLevel - ZOOM_STEP);
                applyZoom();
                redrawCanvasFromHistory();
                showMessage(`Zoom: ${Math.round(zoomLevel * 100)}%`);
            } else {
                showMessage("Minimum zoom reached.");
            }
        });

        function applyZoom() {
            // Apply CSS transform for visual scaling
            canvas.style.transform = `scale(${zoomLevel})`;
            // Adjust the actual CSS width/height of the canvas element to reflect the scaled size
            // This ensures the parent container's scrollbars appear correctly if the canvas overflows
            canvas.style.width = `${canvas.width * zoomLevel}px`;
            canvas.style.height = `${canvas.height * zoomLevel}px`;

            // Adjust drawing properties for the next strokes based on new zoom level
            ctx.lineWidth = lineWidthInput.value / zoomLevel;
            // Glow blur should not scale with zoom visually, so keep its base value
            ctx.shadowBlur = glowBlurInput.value;
        }

        function redrawCanvasFromHistory() {
            // This function is called after zoom changes to redraw the current history state
            // It ensures that the image is drawn correctly *before* the CSS scale is applied.
            if (historyPointer !== -1) {
                const imageData = drawingHistory[historyPointer];
                const img = new Image();
                img.src = imageData;
                img.onload = () => {
                    ctx.save();
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform to clear and draw base image
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    ctx.restore(); // Restore original transform (which includes zoom)
                };
            } else {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }
        }
// --- Sign Function ---
        signBtn.addEventListener('click', () => {
            showSignPrompt();
        });

        function showSignPrompt() {
            messageBoxText.innerHTML = `
                <p class="text-lg font-medium mb-3">Sign Your Artwork</p>
                <input type="text" id="signerNameInput" placeholder="Enter your name" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400 mb-4">
                <label for="signColorPicker" class="block text-sm font-medium text-gray-700 mb-2">Signature Color:</label>
                <input type="color" id="signColorPicker" value="#000000" class="w-full mb-4">
                <div class="flex justify-end w-full space-x-2">
                    <button id="cancelSignBtn" class="bg-gray-200 text-gray-700 hover:bg-gray-300 px-4 py-2 rounded-md">Cancel</button>
                    <button id="nextSignBtn" class="bg-blue-500 text-white hover:bg-blue-600 px-4 py-2 rounded-md">Next</button>
                </div>
            `;
            messageBox.style.display = 'flex';
            messageBoxOverlay.style.display = 'block';

            const signerNameInput = document.getElementById('signerNameInput');
            const signColorPicker = document.getElementById('signColorPicker');
            const cancelSignBtn = document.getElementById('cancelSignBtn');
            const nextSignBtn = document.getElementById('nextSignBtn');

            setTimeout(() => signerNameInput.focus(), 100);

            nextSignBtn.onclick = () => {
                const name = signerNameInput.value.trim();
                const color = signColorPicker.value;
                if (name) {
                    showSignPlacementPrompt(name, color);
                } else {
                    showMessage("Please enter your name.");
                }
            };

            cancelSignBtn.onclick = hideMessageBox;

            signerNameInput.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    nextSignBtn.click();
                }
            };
        }

        function showSignPlacementPrompt(name, color) {
            const today = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            messageBoxText.innerHTML = `
                <p class="text-lg font-medium mb-3">Choose Signature Placement</p>
                <p class="mb-4">Signature: <br><strong>${name}</strong><br>${today}</p>
                <div class="grid grid-cols-2 gap-2 w-full">
                    <button id="topLeftBtn" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Top Left</button>
                    <button id="topRightBtn" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Top Right</button>
                    <button id="bottomLeftBtn" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Bottom Left</button>
                    <button id="bottomRightBtn" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Bottom Right</button>
                </div>
                <button id="cancelPlacementBtn" class="bg-gray-200 text-gray-700 hover:bg-gray-300 mt-4 px-4 py-2 rounded-md w-full">Cancel</button>
            `;
            messageBox.style.display = 'flex';
            messageBoxOverlay.style.display = 'block';

            const topLeftBtn = document.getElementById('topLeftBtn');
            const topRightBtn = document.getElementById('topRightBtn');
            const bottomLeftBtn = document.getElementById('bottomLeftBtn');
            const bottomRightBtn = document.getElementById('bottomRightBtn');
            const cancelPlacementBtn = document.getElementById('cancelPlacementBtn');

            const signatureData = { name: name, date: today, color: color };

            topLeftBtn.onclick = () => { placeSignature(signatureData, 'topLeft'); hideMessageBox(); };
            topRightBtn.onclick = () => { placeSignature(signatureData, 'topRight'); hideMessageBox(); };
            bottomLeftBtn.onclick = () => { placeSignature(signatureData, 'bottomLeft'); hideMessageBox(); };
            bottomRightBtn.onclick = () => { placeSignature(signatureData, 'bottomRight'); hideMessageBox(); };
            cancelPlacementBtn.onclick = hideMessageBox;
        }

        function placeSignature(signature, position) {
            const fontSizeName = 24; // Font size for name
            const fontSizeDate = 18; // Font size for date
            const padding = 20; // Padding from canvas edges

            ctx.save(); // Save current drawing state (including current zoom transform)

            // Temporarily reset transform for accurate text placement regardless of current zoom
            // This ensures the signature is placed at absolute canvas coordinates.
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            ctx.fillStyle = signature.color; // Use selected color
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.shadowBlur = 0; // No glow for signature

            // Set font for name
            ctx.font = `${fontSizeName}px 'Dancing Script', cursive`;
            const nameWidth = ctx.measureText(signature.name).width;

            // Set font for date
            ctx.font = `${fontSizeDate}px 'Dancing Script', cursive`;
            const dateWidth = ctx.measureText(signature.date).width;

            let xName, yName, xDate, yDate;

            switch (position) {
                case 'topLeft':
                    xName = padding;
                    yName = padding;
                    xDate = padding;
                    yDate = padding + fontSizeName + 5; // 5px spacing between name and date
                    break;
                case 'topRight':
                    xName = canvas.width - nameWidth - padding;
                    yName = padding;
                    xDate = canvas.width - dateWidth - padding;
                    yDate = padding + fontSizeName + 5;
                    break;
                case 'bottomLeft':
                    xName = padding;
                    yName = canvas.height - (fontSizeName + fontSizeDate + 5) - padding;
                    xDate = padding;
                    yDate = canvas.height - fontSizeDate - padding;
                    break;
                case 'bottomRight':
                    xName = canvas.width - nameWidth - padding;
                    yName = canvas.height - (fontSizeName + fontSizeDate + 5) - padding;
                    xDate = canvas.width - dateWidth - padding;
                    yDate = canvas.height - fontSizeDate - padding;
                    break;
            }

            // Draw name
            ctx.font = `${fontSizeName}px 'Dancing Script', cursive`;
            ctx.fillText(signature.name, xName, yName);

            // Draw date
            ctx.font = `${fontSizeDate}px 'Dancing Script', cursive`;
            ctx.fillText(signature.date, xDate, yDate);

            ctx.restore(); // Restore original drawing state (including current zoom)

            saveState(); // Save canvas with signature to history
            showMessage("Signature added to canvas!");
        }


        // --- Message Box Functions ---
        function showMessage(message) {
            messageBoxText.innerHTML = `<p>${message}</p>`; // Use innerHTML for simple messages
            messageBox.style.display = 'flex';
            messageBoxOverlay.style.display = 'block';

            // Re-attach simple close handler for standard messages
            messageBoxCloseBtn.onclick = hideMessageBox;
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
            messageBoxOverlay.style.display = 'none';
        }

        messageBoxOverlay.addEventListener('click', hideMessageBox); // Close if clicking outside box

        // Initialize the drawing board when the window loads
        window.onload = initializeCanvas;

    </script>
</body>
</html>





