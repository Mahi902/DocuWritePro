<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Maker</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Google Material Symbols for icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />

    <style>
        /* Custom styles for a clean, light theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Tailwind's slate-50 */
            color: #334155; /* Tailwind's slate-700 */
            user-select: none; /* Prevent text selection during drag/pan */
        }

        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            font-size: 20px;
        }

        /* Custom scrollbar for the points list */
        .points-list::-webkit-scrollbar {
            width: 6px;
        }
        .points-list::-webkit-scrollbar-track {
            background: #e2e8f0; /* slate-200 */
            border-radius: 10px;
        }
        .points-list::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        .points-list::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }

        /* Custom focus styles for better accessibility and design */
        .custom-focus-ring:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.4); /* blue-600 with opacity */
        }

        /* Ensure the app is full height on mobile */
        .app-container {
            height: 100vh;
            height: -webkit-fill-available; /* For iOS Safari */
        }

        /* Added grab cursor for graph panning */
        #canvas-container {
            cursor: grab;
        }
        #canvas-container.dragging {
            cursor: grabbing;
        }
    </style>
</head>
<body class="overscroll-none">
    <div class="app-container flex flex-col lg:flex-row w-full h-full">
        <!-- Control Panel -->
        <div class="w-full lg:w-80 xl:w-96 bg-white border-b lg:border-b-0 lg:border-r border-slate-200 p-4 sm:p-6 flex-shrink-0">
            <header class="mb-6">
                <h1 class="text-2xl font-bold text-slate-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-blue-600 !text-3xl">query_stats</span>
                    Graph Maker
                </h1>
                <p class="text-sm text-slate-500 mt-1">Plot points, connect lines, and export your graph.</p>
            </header>

            <!-- Add Point Form -->
            <div class="space-y-4">
                <h2 class="text-lg font-semibold text-slate-700">Add a Point</h2>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label for="x-input" class="text-sm font-medium text-slate-600">X Value</label>
                        <input type="number" id="x-input" placeholder="e.g., 5" class="mt-1 w-full p-2 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition">
                    </div>
                    <div>
                        <label for="y-input" class="text-sm font-medium text-slate-600">Y Value</label>
                        <input type="number" id="y-input" placeholder="e.g., -10" class="mt-1 w-full p-2 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition">
                    </div>
                </div>
                <button id="add-point-btn" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-blue-700 active:bg-blue-800 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                    <span class="material-symbols-outlined">add_circle</span>
                    Add Point
                </button>
            </div>

            <!-- Points List -->
            <div class="mt-6">
                <h2 class="text-lg font-semibold text-slate-700 mb-2">Plotted Points</h2>
                <div id="points-list-container" class="points-list h-32 lg:h-48 bg-slate-50 border border-slate-200 rounded-md p-2 overflow-y-auto">
                    <p id="no-points-msg" class="text-sm text-slate-400 text-center mt-4">No points added yet.</p>
                </div>
            </div>

            <!-- Display Settings -->
            <div class="mt-6 space-y-3">
                <h2 class="text-lg font-semibold text-slate-700">Display Settings</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                        <label for="zoom-level" class="font-medium text-slate-600">Zoom Level</label>
                        <div class="flex items-center">
                             <input type="number" id="zoom-level" value="100" min="1" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                             <span class="text-sm text-slate-600 ml-1">%</span>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-pos-x" class="font-medium text-slate-600">Show +X Axis</label>
                           <input type="checkbox" id="show-pos-x" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-neg-x" class="font-medium text-slate-600">Show -X Axis</label>
                           <input type="checkbox" id="show-neg-x" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-pos-y" class="font-medium text-slate-600">Show +Y Axis</label>
                           <input type="checkbox" id="show-pos-y" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-neg-y" class="font-medium text-slate-600">Show -Y Axis</label>
                           <input type="checkbox" id="show-neg-y" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                    </div>
                    <p class="text-xs text-slate-500 pt-2 pb-1">Set maximum positive values (enter magnitude).</p>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-pos-x" class="font-medium text-slate-600 text-xs mr-2">+X Max</label>
                           <input type="number" id="max-pos-x" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-neg-x" class="font-medium text-slate-600 text-xs mr-2">-X Max</label>
                           <input type="number" id="max-neg-x" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-pos-y" class="font-medium text-slate-600 text-xs mr-2">+Y Max</label>
                           <input type="number" id="max-pos-y" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-neg-y" class="font-medium text-slate-600 text-xs mr-2">-Y Max</label>
                           <input type="number" id="max-neg-y" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                    </div>
                    <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md mt-2">
                       <label for="show-numbers" class="font-medium text-slate-600">Show Numbers</label>
                       <input type="checkbox" id="show-numbers" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                    </div>
                    <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                        <label for="label-frequency" class="text-sm font-medium text-slate-600">Label every</label>
                        <input type="number" id="label-frequency" value="5" min="1" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        <span class="text-sm text-slate-600">units</span>
                    </div>
                </div>
            </div>


            <!-- Actions -->
            <div class="mt-6 space-y-3">
                 <div class="flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-slate-700">Actions</h2>
                    <button id="fullscreen-btn" class="text-slate-500 hover:text-blue-600 transition-colors custom-focus-ring rounded-full p-1" title="Toggle Fullscreen">
                        <span id="fullscreen-icon" class="material-symbols-outlined">fullscreen</span>
                    </button>
                 </div>
                 <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                     <label for="connect-dots-toggle" class="text-sm font-medium text-slate-600">Connect Points</label>
                     <button id="connect-dots-toggle" role="switch" aria-checked="false" class="relative inline-flex h-6 w-11 items-center rounded-full bg-slate-300 transition-colors custom-focus-ring">
                         <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                     </button>
                 </div>
                 <div class="grid grid-cols-2 gap-3">
                    <button id="invert-values-btn" class="w-full bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-slate-300 active:bg-slate-400 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">swap_horiz</span>
                        Invert
                    </button>
                    <button id="clear-graph-btn" class="w-full bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-slate-300 active:bg-slate-400 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">delete</span>
                        Clear
                    </button>
                 </div>
                <div class="grid grid-cols-2 gap-3">
                    <button id="export-png-btn" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-green-700 active:bg-green-800 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">download</span>
                        Export as PNG
                    </button>
                    <button id="export-jpg-btn" class="w-full bg-amber-500 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-amber-600 active:bg-amber-700 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">download</span>
                        Export as JPG
                    </button>
                </div>
            </div>
        </div>

        <!-- Graph Area -->
        <div class="flex-grow p-4 bg-slate-50 relative overflow-hidden" id="canvas-container">
            <canvas id="graph-canvas"></canvas>
            <div id="coords-tooltip" class="absolute hidden bg-slate-800 text-white text-xs font-mono rounded-md px-2 py-1 pointer-events-none shadow-lg"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');
            const xInput = document.getElementById('x-input');
            const yInput = document.getElementById('y-input');
            const addPointBtn = document.getElementById('add-point-btn');
            const pointsListContainer = document.getElementById('points-list-container');
            const noPointsMsg = document.getElementById('no-points-msg');
            const connectDotsToggle = document.getElementById('connect-dots-toggle');
            const invertValuesBtn = document.getElementById('invert-values-btn');
            const clearGraphBtn = document.getElementById('clear-graph-btn');
            const exportPngBtn = document.getElementById('export-png-btn');
            const exportJpgBtn = document.getElementById('export-jpg-btn');
            const coordsTooltip = document.getElementById('coords-tooltip');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const fullscreenIcon = document.getElementById('fullscreen-icon');
            const appContainer = document.querySelector('.app-container');

            // --- Display Settings Elements ---
            const showPosXCheck = document.getElementById('show-pos-x');
            const showNegXCheck = document.getElementById('show-neg-x');
            const showPosYCheck = document.getElementById('show-pos-y');
            const showNegYCheck = document.getElementById('show-neg-y');
            const showNumbersCheck = document.getElementById('show-numbers');
            const labelFrequencyInput = document.getElementById('label-frequency');
            const maxPosXInput = document.getElementById('max-pos-x');
            const maxNegXInput = document.getElementById('max-neg-x');
            const maxPosYInput = document.getElementById('max-pos-y');
            const maxNegYInput = document.getElementById('max-neg-y');
            const zoomLevelInput = document.getElementById('zoom-level'); 

            // --- State ---
            let points = [];
            let connectDots = false;
            let hoveredPointIndex = -1;

            // --- Display State ---
            let showPosX = true;
            let showNegX = true;
            let showPosY = true;
            let showNegY = true;
            let showNumbers = true;
            let labelFrequency = 5;

            // Manual max/min limits (used to constrain the graph view)
            let manualMaxPosX = null, manualMaxNegX = null, manualMaxPosY = null, manualMaxNegY = null;

            // --- Panning State ---
            let isDragging = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            // --- Graph Configuration ---
            let originX, originY;
            let canvasWidth, canvasHeight; // Tracks the non-DPR dimensions for resize calculation

            // Base scale is 20 pixels per unit. Zoom % will multiply this.
            const BASE_SCALE = 20;
            let currentZoomPercent = 100;
            let scaleX = BASE_SCALE, scaleY = BASE_SCALE; 
            
            const gridColor = '#e2e8f0'; // slate-200
            const axisColor = '#94a3b8';  // slate-400
            const textColor = '#64748b';  // slate-500
            const pointColor = '#2563eb'; // blue-600
            const pointHighlightColor = '#dc2626'; // red-600
            const lineColor = '#3b82f6';  // blue-500

            /**
             * Updates the scale based on the zoom percentage.
             */
            function updateScale(zoomPercent) {
                currentZoomPercent = zoomPercent;
                const zoomFactor = currentZoomPercent / 100;
                scaleX = BASE_SCALE * zoomFactor;
                scaleY = BASE_SCALE * zoomFactor;
                drawGraph();
            }

            /**
             * Resizes the canvas to fit its container and redraws the graph.
             * Crucially, this repositions the origin so it remains centered relative to the new canvas size,
             * preserving any panning offset the user has applied.
             */
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvasContainer.getBoundingClientRect();
                
                // Store old dimensions before updating
                const oldWidth = canvasWidth;
                const oldHeight = canvasHeight;

                // Update canvas properties
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                
                // Store new dimensions
                canvasWidth = rect.width;
                canvasHeight = rect.height;

                // Calculate new center coordinates
                const newCenterX = canvasWidth / 2;
                const newCenterY = canvasHeight / 2;
                
                if (typeof originX === 'undefined' || typeof oldWidth === 'undefined') {
                    // Initialization: Set to center
                    originX = newCenterX;
                    originY = newCenterY;
                } else {
                    // Adjustment: Calculate the shift in the center position and apply it to the current origin
                    const oldCenterX = oldWidth / 2;
                    const oldCenterY = oldHeight / 2;
                    
                    const deltaX = newCenterX - oldCenterX;
                    const deltaY = newCenterY - oldCenterY;
                    
                    // Update origin position, preserving the relative pan distance
                    originX += deltaX;
                    originY += deltaY;
                }

                drawGraph();
            }

            /**
             * Converts graph X coordinate to canvas X coordinate.
             * @param {number} x - The graph X coordinate.
             * @returns {number} The canvas X coordinate.
             */
            function toCanvasX(x) {
                return originX + x * scaleX;
            }

            /**
             * Converts graph Y coordinate to canvas Y coordinate.
             * @param {number} y - The graph Y coordinate.
             * @returns {number} The canvas Y coordinate.
             */
            function toCanvasY(y) {
                return originY - y * scaleY;
            }

            /**
             * Converts canvas X coordinate to graph X coordinate.
             * @param {number} cx - The canvas X coordinate.
             * @returns {number} The graph X coordinate.
             */
            function fromCanvasX(cx) {
                return (cx - originX) / scaleX;
            }

            /**
             * Converts canvas Y coordinate to graph Y coordinate.
             * @param {number} cy - The canvas Y coordinate.
             * @returns {number} The graph Y coordinate.
             */
            function fromCanvasY(cy) {
                return (originY - cy) / scaleY;
            }

            /**
             * Draws the entire graph: grid, axes, points, and lines.
             */
            function drawGraph() {
                const dpr = window.devicePixelRatio || 1;
                const width = canvas.width / dpr;
                const height = canvas.height / dpr;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Calculate the graph coordinates at the canvas edges
                const graphRightEdge = fromCanvasX(width);
                const graphLeftEdge = fromCanvasX(0);
                const graphTopEdge = fromCanvasY(0);
                const graphBottomEdge = fromCanvasY(height);

                // Determine the graph limits for iteration, prioritizing manual limits
                // Manual limits store the positive magnitude. Negative limits are created here.
                const graphRightLimit = manualMaxPosX ?? graphRightEdge;
                const graphLeftLimit = manualMaxNegX ? -manualMaxNegX : graphLeftEdge;
                const graphTopLimit = manualMaxPosY ?? graphTopEdge;
                const graphBottomLimit = manualMaxNegY ? -manualMaxNegY : graphBottomEdge;
                
                // Determine the canvas coordinate endpoints for the axes and drawing boundaries
                const xPosEnd = manualMaxPosX !== null ? Math.min(toCanvasX(manualMaxPosX), width) : width;
                const xNegEnd = manualMaxNegX !== null ? Math.max(toCanvasX(-manualMaxNegX), 0) : 0;
                const yPosEnd = manualMaxPosY !== null ? Math.max(toCanvasY(manualMaxPosY), 0) : 0;
                const yNegEnd = manualMaxNegY !== null ? Math.min(toCanvasY(-manualMaxNegY), height) : height;

                // --- Draw Grid ---
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;
                ctx.font = '10px Inter';

                // Vertical lines (Positive X)
                for (let i = 1; i < graphRightLimit; i++) {
                    const x = toCanvasX(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (x > width || (manualMaxPosX !== null && x > xPosEnd)) break;
                    if (x < 0 || (manualMaxNegX !== null && x < xNegEnd)) continue;

                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }

                // Vertical lines (Negative X)
                for (let i = -1; i > graphLeftLimit; i--) {
                    const x = toCanvasX(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (x < 0 || (manualMaxNegX !== null && x < xNegEnd)) break;
                    if (x > width || (manualMaxPosX !== null && x > xPosEnd)) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }

                // Horizontal lines (Positive Y)
                for (let i = 1; i < graphTopLimit; i++) {
                    const y = toCanvasY(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (y < 0 || (manualMaxPosY !== null && y < yPosEnd)) break;
                    if (y > height || (manualMaxNegY !== null && y > yNegEnd)) continue;

                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Horizontal lines (Negative Y)
                for (let i = -1; i > graphBottomLimit; i--) {
                    const y = toCanvasY(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (y > height || (manualMaxNegY !== null && y > yNegEnd)) break;
                    if (y < 0 || (manualMaxPosY !== null && y < yPosEnd)) continue;

                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // --- Draw Axes ---
                ctx.strokeStyle = axisColor;
                ctx.lineWidth = 2;

                // X-Axis
                if (showPosX || showNegX) {
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    
                    // Draw Positive X part
                    if (showPosX) {
                        ctx.lineTo(xPosEnd, originY);
                    } else {
                        ctx.moveTo(xNegEnd, originY); // Move to the negative end if only negative is shown
                    }
                    
                    // Draw Negative X part
                    if (showNegX) {
                        if (showPosX) ctx.moveTo(originX, originY); // Move back to origin if both axes are shown
                        ctx.lineTo(xNegEnd, originY);
                    }
                    ctx.stroke();
                }

                // Y-Axis
                if (showPosY || showNegY) {
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    
                    // Draw Positive Y part
                    if (showPosY) {
                        ctx.lineTo(originX, yPosEnd);
                    } else {
                        ctx.moveTo(originX, yNegEnd); // Move to the negative end if only negative is shown
                    }
                    
                    // Draw Negative Y part
                    if (showNegY) {
                        if (showPosY) ctx.moveTo(originX, originY); // Move back to origin if both axes are shown
                        ctx.lineTo(originX, yNegEnd);
                    }
                    ctx.stroke();
                }

                // --- Draw Axis Labels ---
                if (showNumbers) {
                    ctx.fillStyle = textColor;
                    ctx.font = '10px Inter';
                    
                    // X-axis labels alignment: center over tick, slightly below axis
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; 
                    
                    const labelY = (originY > height - 15) ? height - 5 :
                                   (originY < 15) ? 15 : originY + 15;


                    // X-axis labels (Positive)
                    for (let i = labelFrequency; i < graphRightLimit; i += labelFrequency) {
                        const x = toCanvasX(i);
                        if (x < width && x > 0 && showPosX) {
                            // Draw a small tick mark
                            if (Math.abs(originY) < height && Math.abs(originY) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(x, originY - 3);
                                ctx.lineTo(x, originY + 3);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                           ctx.fillText(i, x, labelY); // Centered text
                        }
                    }
                    
                    // X-axis labels (Negative)
                    for (let i = -labelFrequency; i > graphLeftLimit; i -= labelFrequency) {
                       const x = toCanvasX(i);
                       if (x > 0 && x < width && showNegX) {
                           // Draw a small tick mark
                            if (Math.abs(originY) < height && Math.abs(originY) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(x, originY - 3);
                                ctx.lineTo(x, originY + 3);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                           ctx.fillText(i, x, labelY); // Centered text
                       }
                    }
                    
                    // Y-axis labels alignment: right-aligned, centered vertically
                    ctx.textAlign = 'right'; 
                    ctx.textBaseline = 'middle'; 

                    const labelX = (originX < 28) ? 5 : 
                                   (originX > width - 30) ? width - 5 : originX - 5; // 5px padding from originX

                    // Y-axis labels (Positive)
                    for (let i = labelFrequency; i < graphTopLimit; i += labelFrequency) {
                        const y = toCanvasY(i);
                        if (y > 0 && y < height && showPosY) {
                            // Draw a small tick mark
                            if (Math.abs(originX) < width && Math.abs(originX) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(originX - 3, y);
                                ctx.lineTo(originX + 3, y);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                            ctx.fillText(i, labelX, y); // Vertically centered text
                        }
                    }
                    // Y-axis labels (Negative)
                    for (let i = -labelFrequency; i > graphBottomLimit; i -= labelFrequency) {
                        const y = toCanvasY(i);
                        if (y < height && y > 0 && showNegY) {
                            // Draw a small tick mark
                            if (Math.abs(originX) < width && Math.abs(originX) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(originX - 3, y);
                                ctx.lineTo(originX + 3, y);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                            ctx.fillText(i, labelX, y); // Vertically centered text
                        }
                    }
                    
                    // Origin label '0' - Corrected alignment (bottom-left quadrant of intersection)
                    if (originX > 0 && originX < width && originY > 0 && originY < height) {
                        ctx.textAlign = 'left'; 
                        ctx.textBaseline = 'top';
                        ctx.fillText('0', originX + 2, originY + 2);
                    }
                }

                // --- Draw Connecting Line ---
                if (connectDots && points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(points[0].x), toCanvasY(points[0].y));
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(toCanvasX(points[i].x), toCanvasY(points[i].y));
                    }
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // --- Draw Points ---
                points.forEach((point, index) => {
                    const cx = toCanvasX(point.x);
                    const cy = toCanvasY(point.y);

                    // Only draw points that are within the visible graph limits
                    const isVisibleX = (manualMaxPosX === null || point.x <= manualMaxPosX) && 
                                       (manualMaxNegX === null || point.x >= -manualMaxNegX);
                    const isVisibleY = (manualMaxPosY === null || point.y <= manualMaxPosY) && 
                                       (manualMaxNegY === null || point.y >= -manualMaxNegY);

                    if (isVisibleX && isVisibleY) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                        ctx.fillStyle = (index === hoveredPointIndex) ? pointHighlightColor : pointColor;
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            }

            /**
             * Updates the list of points displayed in the control panel.
             */
            function updatePointsList() {
                pointsListContainer.innerHTML = '';
                if (points.length === 0) {
                    pointsListContainer.appendChild(noPointsMsg);
                    noPointsMsg.style.display = 'block';
                } else {
                    noPointsMsg.style.display = 'none';
                    points.forEach((point, index) => {
                        const div = document.createElement('div');
                        div.className = 'flex items-center justify-between p-2 rounded-md hover:bg-slate-200 transition-colors text-sm';
                        div.innerHTML = `
                            <span class="font-mono text-slate-700">(${point.x}, ${point.y})</span>
                            <button data-index="${index}" class="delete-point-btn text-slate-400 hover:text-red-500 transition-colors">
                                <span class="material-symbols-outlined !text-base">close</span>
                            </button>
                        `;
                        pointsListContainer.appendChild(div);
                    });
                }
            }

            /**
             * Handles adding a new point to the graph.
             */
            function handleAddPoint() {
                const x = parseFloat(xInput.value);
                const y = parseFloat(yInput.value);

                if (!isNaN(x) && !isNaN(y)) {
                    points.push({ x, y });
                    xInput.value = '';
                    yInput.value = '';
                    xInput.focus();
                    updatePointsList();
                    drawGraph();
                }
            }

            // --- Event Listeners ---

            // FIX 1: Zoom Input Handling for Deletion and Validation
            zoomLevelInput.addEventListener('input', () => {
                const rawValue = zoomLevelInput.value.trim();
                let zoom;

                if (rawValue === '') {
                    // Allow input to be empty while typing, use default scale 100% for drawing
                    zoom = 100; 
                } else {
                    zoom = parseInt(rawValue, 10);
                    if (isNaN(zoom) || zoom < 1) {
                        // Use a minimum scale of 1% for drawing if input is invalid or too low
                        zoom = 1; 
                    }
                }
                updateScale(zoom);
            });
            
            zoomLevelInput.addEventListener('blur', () => {
                const rawValue = zoomLevelInput.value.trim();
                let zoom = parseInt(rawValue, 10);
                
                // If the user blurs the field and it's empty or invalid, reset it to a valid value
                if (rawValue === '' || isNaN(zoom) || zoom < 1) {
                    zoomLevelInput.value = 100;
                    updateScale(100);
                }
            });


            addPointBtn.addEventListener('click', handleAddPoint);
            xInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') yInput.focus(); });
            yInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleAddPoint(); });

            pointsListContainer.addEventListener('click', (e) => {
                if (e.target.closest('.delete-point-btn')) {
                    const index = parseInt(e.target.closest('.delete-point-btn').dataset.index, 10);
                    points.splice(index, 1);
                    updatePointsList();
                    drawGraph();
                }
            });

            connectDotsToggle.addEventListener('click', () => {
                connectDots = !connectDots;
                const span = connectDotsToggle.querySelector('span');
                if (connectDots) {
                    connectDotsToggle.setAttribute('aria-checked', 'true');
                    connectDotsToggle.classList.remove('bg-slate-300');
                    connectDotsToggle.classList.add('bg-blue-600');
                    span.style.transform = 'translateX(20px)';
                } else {
                    connectDotsToggle.setAttribute('aria-checked', 'false');
                    connectDotsToggle.classList.remove('bg-blue-600');
                    connectDotsToggle.classList.add('bg-slate-300');
                    span.style.transform = 'translateX(0)';
                }
                drawGraph();
            });

            invertValuesBtn.addEventListener('click', () => {
                points = points.map(p => ({ x: -p.x, y: -p.y }));
                updatePointsList();
                drawGraph();
            });

            clearGraphBtn.addEventListener('click', () => {
                points = [];
                updatePointsList();
                drawGraph();
            });

            exportPngBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'graph.png';
                // Captures the current high-resolution state of the canvas
                link.href = canvas.toDataURL('image/png');
                link.click();
            });

            exportJpgBtn.addEventListener('click', () => {
                // To export as JPG, we need to fill the background as JPG doesn't support transparency
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;

                // Fill background with the same color as the graph area
                tempCtx.fillStyle = '#f8fafc'; // slate-50
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // Draw the current canvas content onto the temp canvas
                tempCtx.drawImage(canvas, 0, 0);

                // Trigger download
                const link = document.createElement('a');
                link.download = 'graph.jpg';
                link.href = tempCanvas.toDataURL('image/jpeg', 0.9); // 0.9 quality
                link.click();
            });

            // --- Panning Logic (Scroll/Drag) ---
            canvasContainer.addEventListener('mousedown', (e) => {
                // Only start dragging with the left mouse button (0)
                if (e.button === 0) {
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvasContainer.classList.add('dragging');
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    canvasContainer.classList.remove('dragging');
                }
            });

            document.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Tooltip logic
                const graphX = fromCanvasX(mouseX).toFixed(2);
                const graphY = fromCanvasY(mouseY).toFixed(2);
                coordsTooltip.style.display = 'block';
                coordsTooltip.style.left = `${mouseX + 15}px`;
                coordsTooltip.style.top = `${mouseY + 15}px`;
                coordsTooltip.textContent = `(${graphX}, ${graphY})`;

                // Panning logic
                if (isDragging) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;

                    originX += dx;
                    originY += dy;

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;

                    drawGraph();
                }

                // Hover logic
                let foundPoint = false;
                if (!isDragging) { // Avoid hovering while actively dragging
                    for (let i = 0; i < points.length; i++) {
                        const canvasX = toCanvasX(points[i].x);
                        const canvasY = toCanvasY(points[i].y);
                        const distance = Math.sqrt((mouseX - canvasX) ** 2 + (mouseY - canvasY) ** 2);
                        if (distance < 8) { // Hover radius
                            if (hoveredPointIndex !== i) {
                                hoveredPointIndex = i;
                                drawGraph();
                            }
                            foundPoint = true;
                            break;
                        }
                    }
                }

                if (!foundPoint && hoveredPointIndex !== -1) {
                    hoveredPointIndex = -1;
                    drawGraph();
                }
            });
            
            canvasContainer.addEventListener('mouseleave', () => {
                coordsTooltip.style.display = 'none';
                if (isDragging) {
                    isDragging = false;
                    canvasContainer.classList.remove('dragging');
                }
            });


            // --- Display Settings Listeners (Axis checks and limits) ---
            showPosXCheck.addEventListener('change', () => { showPosX = showPosXCheck.checked; drawGraph(); });
            showNegXCheck.addEventListener('change', () => { showNegX = showNegXCheck.checked; drawGraph(); });
            showPosYCheck.addEventListener('change', () => { showPosY = showPosYCheck.checked; drawGraph(); });
            showNegYCheck.addEventListener('change', () => { showNegY = showNegYCheck.checked; drawGraph(); });
            showNumbersCheck.addEventListener('change', () => { showNumbers = showNumbersCheck.checked; drawGraph(); });

            labelFrequencyInput.addEventListener('change', () => {
                const freq = parseInt(labelFrequencyInput.value, 10);
                if (!isNaN(freq) && freq > 0) {
                    labelFrequency = freq;
                    drawGraph();
                }
            });

            // Helper function for axis limit inputs
            function createAxisLimitListener(inputElement, stateKey) {
                inputElement.addEventListener('change', () => {
                    const value = parseFloat(inputElement.value);
                    if (!isNaN(value) && value > 0) {
                        // All keys store the POSITIVE magnitude of the limit
                        window[stateKey] = value;
                    } else {
                        window[stateKey] = null;
                    }
                    drawGraph();
                });
            }

            createAxisLimitListener(maxPosXInput, 'manualMaxPosX');
            createAxisLimitListener(maxNegXInput, 'manualMaxNegX');
            createAxisLimitListener(maxPosYInput, 'manualMaxPosY');
            createAxisLimitListener(maxNegYInput, 'manualMaxNegY');


            // --- Fullscreen Logic ---
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    // Entering fullscreen
                    appContainer.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else {
                    // Exiting fullscreen
                    document.exitFullscreen();
                }
            });

            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement) {
                    fullscreenIcon.textContent = 'fullscreen_exit';
                } else {
                    fullscreenIcon.textContent = 'fullscreen';
                }
                // Recalculate canvas size and reposition origin on fullscreen change
                resizeCanvas();
            });

            // --- Initialization ---
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            updatePointsList();
            updateScale(currentZoomPercent); // Apply initial zoom
        });
    </script>
</body>
</html>
