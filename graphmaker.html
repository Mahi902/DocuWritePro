<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Maker</title>
    <meta name="description" content="DocuWrite Pro is an all-in-one online workspace that lets you write, edit, convert, design, and manage documents and digital content instantly—no installation, no complexity.">
  <meta name="keywords" content="DocuWrite Pro, Mohtadi Azad Mahi, AI writer, document editor, online text tool, GitHub project, DocuWritePro, Document Editor, Document, Editor, PDF, JPG, Edit, Text, Change File Type, File Changer, Format, Format Changer, Office, Docs, A4, Editor, General document editing, Collab, Editing documents together, Document Viewer, Viewing documents, Word Finder, Searching for specific words, Translator, Language translation, Document Signer, Electronically signing documents, Page Number Adder, Adding page numbers to documents, Chart Maker, Creating data charts, Table Maker, Creating tables, Watermark Adder, Adding watermarks to files, Email Writer, Assisting with writing emails, Spell Checker, Checking spelling and grammar, File Extractor, Extracting contents from files, QR Maker, Creating QR codes, ID Card Maker, Designing and creating ID cards, File Zipper, Compressing or zipping files, PDF Converter, Converting files to or from PDF format, Context Field, Analyzing text (e.g., word count, frequency), Gift Card Maker, Creating custom gift cards, Share File, Uploading or sharing a file, Text Extractor, Extracting text from sources (e.g., images), Keyboard Click Test, Testing keyboard functionality, Frontend IDE, Integrated Development Environment for frontend coding, HTML Editor, Editing HTML code, HTML Writer, Writing or generating HTML content, Button Designer, Designing user interface buttons, HTML Splitter, Splitting HTML files or elements, GoTo Code, Navigation feature in an IDE/editor, Code Snipper, Storing or managing code snippets, Image Editor, Editing images, Image Generator, Generating new images, Drawing Board, A simple drawing or sketching tool, HTML, CSS, JS, Online, Fast, Easy, No login, No signup, Free, No credit card required, Mohtadi, Azad, Mahi, Mohtadi Azad, Mohtadi Azad Mahi, mahi902">
  <meta name="author" content="Mohtadi Azad Mahi">
  <meta name="robots" content="index, follow">

  <!-- Favicon & App Icons -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <link rel="icon" type="image/png" sizes="192x192" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <link rel="apple-touch-icon" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
  <meta name="theme-color" content="#ffffff">

  <!-- App & Brand Metadata -->
  <meta property="og:site_name" content="DocuWrite Pro">
  <meta name="application-name" content="DocuWrite Pro">
  <meta name="apple-mobile-web-app-title" content="DocuWrite Pro">

  <!-- Open Graph -->
  <meta property="og:title" content="DocuWrite Pro — Online Document Editor">
  <meta property="og:description" content="Edit, format, and export documents easily with DocuWrite Pro by Mohtadi Azad Mahi.">
  <meta property="og:url" content="https://mahi902.github.io/DocuWritePro/">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">

  <!-- Twitter Cards -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="DocuWrite Pro — Online Document Editor">
  <meta name="twitter:description" content="Create, format, and export documents easily with DocuWrite Pro. Built by Mohtadi Azad Mahi.">
  <meta name="twitter:image" content="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">

  <!-- Structured Data (Google Knowledge Graph) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "DocuWrite Pro",
    "alternateName": "DocuWrite Pro — Online Document Editor",
    "url": "https://mahi902.github.io/DocuWritePro/",
    "creator": {
      "@type": "Person",
      "name": "Mohtadi Azad Mahi"
    }
  }
  </script>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Google Material Symbols for icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />

    <style>
        /* Custom styles for a clean, light theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Tailwind's slate-50 */
            color: #334155; /* Tailwind's slate-700 */
            user-select: none; /* Prevent text selection during drag/pan */
        }

        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            font-size: 20px;
        }

        /* Custom scrollbar for the points list */
        .points-list::-webkit-scrollbar {
            width: 6px;
        }
        .points-list::-webkit-scrollbar-track {
            background: #e2e8f0; /* slate-200 */
            border-radius: 10px;
        }
        .points-list::-webkit-scrollbar-thumb {
            background: #94a3b8; /* slate-400 */
            border-radius: 10px;
        }
        .points-list::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* slate-500 */
        }

        /* Custom focus styles for better accessibility and design */
        .custom-focus-ring:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.4); /* blue-600 with opacity */
        }

        /* Ensure the app is full height on mobile */
        .app-container {
            height: 100vh;
            height: -webkit-fill-available; /* For iOS Safari */
        }

        /* Added grab cursor for graph panning */
        #canvas-container {
            cursor: grab;
        }
        #canvas-container.dragging {
            cursor: grabbing;
        }
    </style>
</head>
<body class="overscroll-none">
    <div class="app-container flex flex-col lg:flex-row w-full h-full">
        <!-- Control Panel -->
        <div class="w-full lg:w-80 xl:w-96 bg-white border-b lg:border-b-0 lg:border-r border-slate-200 p-4 sm:p-6 flex-shrink-0">
            <header class="mb-6">
                <h1 class="text-2xl font-bold text-slate-800 flex items-center gap-2">
                    <span class="material-symbols-outlined text-blue-600 !text-3xl">query_stats</span>
                    Graph Maker
                </h1>
                <p class="text-sm text-slate-500 mt-1">Plot points, connect lines, and export your graph.</p>
            </header>

            <!-- Add Point Form -->
            <div class="space-y-4">
                <h2 class="text-lg font-semibold text-slate-700">Add a Point</h2>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label for="x-input" class="text-sm font-medium text-slate-600">X Value</label>
                        <input type="number" id="x-input" placeholder="e.g., 5" class="mt-1 w-full p-2 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition">
                    </div>
                    <div>
                        <label for="y-input" class="text-sm font-medium text-slate-600">Y Value</label>
                        <input type="number" id="y-input" placeholder="e.g., -10" class="mt-1 w-full p-2 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition">
                    </div>
                </div>
                <button id="add-point-btn" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-blue-700 active:bg-blue-800 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                    <span class="material-symbols-outlined">add_circle</span>
                    Add Point
                </button>
            </div>

            <!-- Points List -->
            <div class="mt-6">
                <h2 class="text-lg font-semibold text-slate-700 mb-2">Plotted Points</h2>
                <div id="points-list-container" class="points-list h-32 lg:h-48 bg-slate-50 border border-slate-200 rounded-md p-2 overflow-y-auto">
                    <p id="no-points-msg" class="text-sm text-slate-400 text-center mt-4">No points added yet.</p>
                </div>
            </div>

            <!-- Display Settings -->
            <div class="mt-6 space-y-3">
                <h2 class="text-lg font-semibold text-slate-700">Display Settings</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                        <label for="zoom-level" class="font-medium text-slate-600">Zoom Level</label>
                        <div class="flex items-center">
                             <input type="number" id="zoom-level" value="100" min="1" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                             <span class="text-sm text-slate-600 ml-1">%</span>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-pos-x" class="font-medium text-slate-600">Show +X Axis</label>
                           <input type="checkbox" id="show-pos-x" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-neg-x" class="font-medium text-slate-600">Show -X Axis</label>
                           <input type="checkbox" id="show-neg-x" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-pos-y" class="font-medium text-slate-600">Show +Y Axis</label>
                           <input type="checkbox" id="show-pos-y" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                        <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                           <label for="show-neg-y" class="font-medium text-slate-600">Show -Y Axis</label>
                           <input type="checkbox" id="show-neg-y" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                        </div>
                    </div>
                    <p class="text-xs text-slate-500 pt-2 pb-1">Set maximum positive values (enter magnitude).</p>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-pos-x" class="font-medium text-slate-600 text-xs mr-2">+X Max</label>
                           <input type="number" id="max-pos-x" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-neg-x" class="font-medium text-slate-600 text-xs mr-2">-X Max</label>
                           <input type="number" id="max-neg-x" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-pos-y" class="font-medium text-slate-600 text-xs mr-2">+Y Max</label>
                           <input type="number" id="max-pos-y" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                        <div class="flex items-center justify-between bg-slate-50 p-2 rounded-md border border-slate-200">
                           <label for="max-neg-y" class="font-medium text-slate-600 text-xs mr-2">-Y Max</label>
                           <input type="number" id="max-neg-y" placeholder="Auto" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        </div>
                    </div>
                    <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md mt-2">
                       <label for="show-numbers" class="font-medium text-slate-600">Show Numbers</label>
                       <input type="checkbox" id="show-numbers" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500" checked>
                    </div>
                    <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                        <label for="label-frequency" class="text-sm font-medium text-slate-600">Label every</label>
                        <input type="number" id="label-frequency" value="5" min="1" class="w-20 p-1 border border-slate-300 rounded-md shadow-sm custom-focus-ring transition text-center">
                        <span class="text-sm text-slate-600">units</span>
                    </div>
                </div>
            </div>


            <!-- Actions -->
            <div class="mt-6 space-y-3">
                 <div class="flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-slate-700">Actions</h2>
                    <button id="fullscreen-btn" class="text-slate-500 hover:text-blue-600 transition-colors custom-focus-ring rounded-full p-1" title="Toggle Fullscreen">
                        <span id="fullscreen-icon" class="material-symbols-outlined">fullscreen</span>
                    </button>
                 </div>
                 <div class="flex items-center justify-between bg-slate-100 p-2 rounded-md">
                     <label for="connect-dots-toggle" class="text-sm font-medium text-slate-600">Connect Points</label>
                     <button id="connect-dots-toggle" role="switch" aria-checked="false" class="relative inline-flex h-6 w-11 items-center rounded-full bg-slate-300 transition-colors custom-focus-ring">
                         <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                     </button>
                 </div>
                 <div class="grid grid-cols-2 gap-3">
                    <button id="invert-values-btn" class="w-full bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-slate-300 active:bg-slate-400 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">swap_horiz</span>
                        Invert
                    </button>
                    <button id="clear-graph-btn" class="w-full bg-slate-200 text-slate-700 font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-slate-300 active:bg-slate-400 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">delete</span>
                        Clear
                    </button>
                 </div>
                <div class="grid grid-cols-2 gap-3">
                    <button id="export-png-btn" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-green-700 active:bg-green-800 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">download</span>
                        Export as PNG
                    </button>
                    <button id="export-jpg-btn" class="w-full bg-amber-500 text-white font-semibold py-2 px-4 rounded-md shadow-sm hover:bg-amber-600 active:bg-amber-700 transition-all flex items-center justify-center gap-2 custom-focus-ring">
                        <span class="material-symbols-outlined">download</span>
                        Export as JPG
                    </button>
                </div>
            </div>
        </div>

        <!-- Graph Area -->
        <div class="flex-grow p-4 bg-slate-50 relative overflow-hidden" id="canvas-container">
            <canvas id="graph-canvas"></canvas>
            <div id="coords-tooltip" class="absolute hidden bg-slate-800 text-white text-xs font-mono rounded-md px-2 py-1 pointer-events-none shadow-lg"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');
            const xInput = document.getElementById('x-input');
            const yInput = document.getElementById('y-input');
            const addPointBtn = document.getElementById('add-point-btn');
            const pointsListContainer = document.getElementById('points-list-container');
            const noPointsMsg = document.getElementById('no-points-msg');
            const connectDotsToggle = document.getElementById('connect-dots-toggle');
            const invertValuesBtn = document.getElementById('invert-values-btn');
            const clearGraphBtn = document.getElementById('clear-graph-btn');
            const exportPngBtn = document.getElementById('export-png-btn');
            const exportJpgBtn = document.getElementById('export-jpg-btn');
            const coordsTooltip = document.getElementById('coords-tooltip');
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const fullscreenIcon = document.getElementById('fullscreen-icon');
            const appContainer = document.querySelector('.app-container');

            // --- Display Settings Elements ---
            const showPosXCheck = document.getElementById('show-pos-x');
            const showNegXCheck = document.getElementById('show-neg-x');
            const showPosYCheck = document.getElementById('show-pos-y');
            const showNegYCheck = document.getElementById('show-neg-y');
            const showNumbersCheck = document.getElementById('show-numbers');
            const labelFrequencyInput = document.getElementById('label-frequency');
            const maxPosXInput = document.getElementById('max-pos-x');
            const maxNegXInput = document.getElementById('max-neg-x');
            const maxPosYInput = document.getElementById('max-pos-y');
            const maxNegYInput = document.getElementById('max-neg-y');
            const zoomLevelInput = document.getElementById('zoom-level'); 

            // --- State ---
            let points = [];
            let connectDots = false;
            let hoveredPointIndex = -1;

            // --- Display State ---
            let showPosX = true;
            let showNegX = true;
            let showPosY = true;
            let showNegY = true;
            let showNumbers = true;
            let labelFrequency = 5;

            // Manual max/min limits (used to constrain the graph view)
            let manualMaxPosX = null, manualMaxNegX = null, manualMaxPosY = null, manualMaxNegY = null;

            // --- Panning State ---
            let isDragging = false;
            let lastMouseX = 0;
            let lastMouseY = 0;

            // --- Graph Configuration ---
            let originX, originY;
            let canvasWidth, canvasHeight; // Tracks the non-DPR dimensions for resize calculation

            // Base scale is 20 pixels per unit. Zoom % will multiply this.
            const BASE_SCALE = 20;
            let currentZoomPercent = 100;
            let scaleX = BASE_SCALE, scaleY = BASE_SCALE; 
            
            const gridColor = '#e2e8f0'; // slate-200
            const axisColor = '#94a3b8';  // slate-400
            const textColor = '#64748b';  // slate-500
            const pointColor = '#2563eb'; // blue-600
            const pointHighlightColor = '#dc2626'; // red-600
            const lineColor = '#3b82f6';  // blue-500

            /**
             * Updates the scale based on the zoom percentage.
             */
            function updateScale(zoomPercent) {
                currentZoomPercent = zoomPercent;
                const zoomFactor = currentZoomPercent / 100;
                scaleX = BASE_SCALE * zoomFactor;
                scaleY = BASE_SCALE * zoomFactor;
                drawGraph();
            }

            /**
             * Resizes the canvas to fit its container and redraws the graph.
             * Crucially, this repositions the origin so it remains centered relative to the new canvas size,
             * preserving any panning offset the user has applied.
             */
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvasContainer.getBoundingClientRect();
                
                // Store old dimensions before updating
                const oldWidth = canvasWidth;
                const oldHeight = canvasHeight;

                // Update canvas properties
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                
                // Store new dimensions
                canvasWidth = rect.width;
                canvasHeight = rect.height;

                // Calculate new center coordinates
                const newCenterX = canvasWidth / 2;
                const newCenterY = canvasHeight / 2;
                
                if (typeof originX === 'undefined' || typeof oldWidth === 'undefined') {
                    // Initialization: Set to center
                    originX = newCenterX;
                    originY = newCenterY;
                } else {
                    // Adjustment: Calculate the shift in the center position and apply it to the current origin
                    const oldCenterX = oldWidth / 2;
                    const oldCenterY = oldHeight / 2;
                    
                    const deltaX = newCenterX - oldCenterX;
                    const deltaY = newCenterY - oldCenterY;
                    
                    // Update origin position, preserving the relative pan distance
                    originX += deltaX;
                    originY += deltaY;
                }

                drawGraph();
            }

            /**
             * Converts graph X coordinate to canvas X coordinate.
             * @param {number} x - The graph X coordinate.
             * @returns {number} The canvas X coordinate.
             */
            function toCanvasX(x) {
                return originX + x * scaleX;
            }

            /**
             * Converts graph Y coordinate to canvas Y coordinate.
             * @param {number} y - The graph Y coordinate.
             * @returns {number} The canvas Y coordinate.
             */
            function toCanvasY(y) {
                return originY - y * scaleY;
            }

            /**
             * Converts canvas X coordinate to graph X coordinate.
             * @param {number} cx - The canvas X coordinate.
             * @returns {number} The graph X coordinate.
             */
            function fromCanvasX(cx) {
                return (cx - originX) / scaleX;
            }

            /**
             * Converts canvas Y coordinate to graph Y coordinate.
             * @param {number} cy - The canvas Y coordinate.
             * @returns {number} The graph Y coordinate.
             */
            function fromCanvasY(cy) {
                return (originY - cy) / scaleY;
            }

            /**
             * Draws the entire graph: grid, axes, points, and lines.
             */
            function drawGraph() {
                const dpr = window.devicePixelRatio || 1;
                const width = canvas.width / dpr;
                const height = canvas.height / dpr;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Calculate the graph coordinates at the canvas edges
                const graphRightEdge = fromCanvasX(width);
                const graphLeftEdge = fromCanvasX(0);
                const graphTopEdge = fromCanvasY(0);
                const graphBottomEdge = fromCanvasY(height);

                // Determine the graph limits for iteration, prioritizing manual limits
                // Manual limits store the positive magnitude. Negative limits are created here.
                const graphRightLimit = manualMaxPosX ?? graphRightEdge;
                const graphLeftLimit = manualMaxNegX ? -manualMaxNegX : graphLeftEdge;
                const graphTopLimit = manualMaxPosY ?? graphTopEdge;
                const graphBottomLimit = manualMaxNegY ? -manualMaxNegY : graphBottomEdge;
                
                // Determine the canvas coordinate endpoints for the axes and drawing boundaries
                const xPosEnd = manualMaxPosX !== null ? Math.min(toCanvasX(manualMaxPosX), width) : width;
                const xNegEnd = manualMaxNegX !== null ? Math.max(toCanvasX(-manualMaxNegX), 0) : 0;
                const yPosEnd = manualMaxPosY !== null ? Math.max(toCanvasY(manualMaxPosY), 0) : 0;
                const yNegEnd = manualMaxNegY !== null ? Math.min(toCanvasY(-manualMaxNegY), height) : height;

                // --- Draw Grid ---
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;
                ctx.font = '10px Inter';

                // Vertical lines (Positive X)
                for (let i = 1; i < graphRightLimit; i++) {
                    const x = toCanvasX(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (x > width || (manualMaxPosX !== null && x > xPosEnd)) break;
                    if (x < 0 || (manualMaxNegX !== null && x < xNegEnd)) continue;

                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }

                // Vertical lines (Negative X)
                for (let i = -1; i > graphLeftLimit; i--) {
                    const x = toCanvasX(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (x < 0 || (manualMaxNegX !== null && x < xNegEnd)) break;
                    if (x > width || (manualMaxPosX !== null && x > xPosEnd)) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }

                // Horizontal lines (Positive Y)
                for (let i = 1; i < graphTopLimit; i++) {
                    const y = toCanvasY(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (y < 0 || (manualMaxPosY !== null && y < yPosEnd)) break;
                    if (y > height || (manualMaxNegY !== null && y > yNegEnd)) continue;

                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // Horizontal lines (Negative Y)
                for (let i = -1; i > graphBottomLimit; i--) {
                    const y = toCanvasY(i);
                    // Only draw if within the visible canvas and the manual limit
                    if (y > height || (manualMaxNegY !== null && y > yNegEnd)) break;
                    if (y < 0 || (manualMaxPosY !== null && y < yPosEnd)) continue;

                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // --- Draw Axes ---
                ctx.strokeStyle = axisColor;
                ctx.lineWidth = 2;

                // X-Axis
                if (showPosX || showNegX) {
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    
                    // Draw Positive X part
                    if (showPosX) {
                        ctx.lineTo(xPosEnd, originY);
                    } else {
                        ctx.moveTo(xNegEnd, originY); // Move to the negative end if only negative is shown
                    }
                    
                    // Draw Negative X part
                    if (showNegX) {
                        if (showPosX) ctx.moveTo(originX, originY); // Move back to origin if both axes are shown
                        ctx.lineTo(xNegEnd, originY);
                    }
                    ctx.stroke();
                }

                // Y-Axis
                if (showPosY || showNegY) {
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    
                    // Draw Positive Y part
                    if (showPosY) {
                        ctx.lineTo(originX, yPosEnd);
                    } else {
                        ctx.moveTo(originX, yNegEnd); // Move to the negative end if only negative is shown
                    }
                    
                    // Draw Negative Y part
                    if (showNegY) {
                        if (showPosY) ctx.moveTo(originX, originY); // Move back to origin if both axes are shown
                        ctx.lineTo(originX, yNegEnd);
                    }
                    ctx.stroke();
                }

                // --- Draw Axis Labels ---
                if (showNumbers) {
                    ctx.fillStyle = textColor;
                    ctx.font = '10px Inter';
                    
                    // X-axis labels alignment: center over tick, slightly below axis
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; 
                    
                    const labelY = (originY > height - 15) ? height - 5 :
                                   (originY < 15) ? 15 : originY + 15;


                    // X-axis labels (Positive)
                    for (let i = labelFrequency; i < graphRightLimit; i += labelFrequency) {
                        const x = toCanvasX(i);
                        if (x < width && x > 0 && showPosX) {
                            // Draw a small tick mark
                            if (Math.abs(originY) < height && Math.abs(originY) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(x, originY - 3);
                                ctx.lineTo(x, originY + 3);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                           ctx.fillText(i, x, labelY); // Centered text
                        }
                    }
                    
                    // X-axis labels (Negative)
                    for (let i = -labelFrequency; i > graphLeftLimit; i -= labelFrequency) {
                       const x = toCanvasX(i);
                       if (x > 0 && x < width && showNegX) {
                           // Draw a small tick mark
                            if (Math.abs(originY) < height && Math.abs(originY) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(x, originY - 3);
                                ctx.lineTo(x, originY + 3);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                           ctx.fillText(i, x, labelY); // Centered text
                       }
                    }
                    
                    // Y-axis labels alignment: right-aligned, centered vertically
                    ctx.textAlign = 'right'; 
                    ctx.textBaseline = 'middle'; 

                    const labelX = (originX < 28) ? 5 : 
                                   (originX > width - 30) ? width - 5 : originX - 5; // 5px padding from originX

                    // Y-axis labels (Positive)
                    for (let i = labelFrequency; i < graphTopLimit; i += labelFrequency) {
                        const y = toCanvasY(i);
                        if (y > 0 && y < height && showPosY) {
                            // Draw a small tick mark
                            if (Math.abs(originX) < width && Math.abs(originX) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(originX - 3, y);
                                ctx.lineTo(originX + 3, y);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                            ctx.fillText(i, labelX, y); // Vertically centered text
                        }
                    }
                    // Y-axis labels (Negative)
                    for (let i = -labelFrequency; i > graphBottomLimit; i -= labelFrequency) {
                        const y = toCanvasY(i);
                        if (y < height && y > 0 && showNegY) {
                            // Draw a small tick mark
                            if (Math.abs(originX) < width && Math.abs(originX) > 0) { 
                                ctx.beginPath();
                                ctx.moveTo(originX - 3, y);
                                ctx.lineTo(originX + 3, y);
                                ctx.strokeStyle = axisColor;
                                ctx.stroke();
                            }
                            ctx.fillText(i, labelX, y); // Vertically centered text
                        }
                    }
                    
                    // Origin label '0' - Corrected alignment (bottom-left quadrant of intersection)
                    if (originX > 0 && originX < width && originY > 0 && originY < height) {
                        ctx.textAlign = 'left'; 
                        ctx.textBaseline = 'top';
                        ctx.fillText('0', originX + 2, originY + 2);
                    }
                }

                // --- Draw Connecting Line ---
                if (connectDots && points.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(toCanvasX(points[0].x), toCanvasY(points[0].y));
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(toCanvasX(points[i].x), toCanvasY(points[i].y));
                    }
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // --- Draw Points ---
                points.forEach((point, index) => {
                    const cx = toCanvasX(point.x);
                    const cy = toCanvasY(point.y);

                    // Only draw points that are within the visible graph limits
                    const isVisibleX = (manualMaxPosX === null || point.x <= manualMaxPosX) && 
                                       (manualMaxNegX === null || point.x >= -manualMaxNegX);
                    const isVisibleY = (manualMaxPosY === null || point.y <= manualMaxPosY) && 
                                       (manualMaxNegY === null || point.y >= -manualMaxNegY);

                    if (isVisibleX && isVisibleY) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
                        ctx.fillStyle = (index === hoveredPointIndex) ? pointHighlightColor : pointColor;
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            }

            /**
             * Updates the list of points displayed in the control panel.
             */
            function updatePointsList() {
                pointsListContainer.innerHTML = '';
                if (points.length === 0) {
                    pointsListContainer.appendChild(noPointsMsg);
                    noPointsMsg.style.display = 'block';
                } else {
                    noPointsMsg.style.display = 'none';
                    points.forEach((point, index) => {
                        const div = document.createElement('div');
                        div.className = 'flex items-center justify-between p-2 rounded-md hover:bg-slate-200 transition-colors text-sm';
                        div.innerHTML = `
                            <span class="font-mono text-slate-700">(${point.x}, ${point.y})</span>
                            <button data-index="${index}" class="delete-point-btn text-slate-400 hover:text-red-500 transition-colors">
                                <span class="material-symbols-outlined !text-base">close</span>
                            </button>
                        `;
                        pointsListContainer.appendChild(div);
                    });
                }
            }

            /**
             * Handles adding a new point to the graph.
             */
            function handleAddPoint() {
                const x = parseFloat(xInput.value);
                const y = parseFloat(yInput.value);

                if (!isNaN(x) && !isNaN(y)) {
                    points.push({ x, y });
                    xInput.value = '';
                    yInput.value = '';
                    xInput.focus();
                    updatePointsList();
                    drawGraph();
                }
            }

            // --- Event Listeners ---

            // FIX 1: Zoom Input Handling for Deletion and Validation
            zoomLevelInput.addEventListener('input', () => {
                const rawValue = zoomLevelInput.value.trim();
                let zoom;

                if (rawValue === '') {
                    // Allow input to be empty while typing, use default scale 100% for drawing
                    zoom = 100; 
                } else {
                    zoom = parseInt(rawValue, 10);
                    if (isNaN(zoom) || zoom < 1) {
                        // Use a minimum scale of 1% for drawing if input is invalid or too low
                        zoom = 1; 
                    }
                }
                updateScale(zoom);
            });
            
            zoomLevelInput.addEventListener('blur', () => {
                const rawValue = zoomLevelInput.value.trim();
                let zoom = parseInt(rawValue, 10);
                
                // If the user blurs the field and it's empty or invalid, reset it to a valid value
                if (rawValue === '' || isNaN(zoom) || zoom < 1) {
                    zoomLevelInput.value = 100;
                    updateScale(100);
                }
            });


            addPointBtn.addEventListener('click', handleAddPoint);
            xInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') yInput.focus(); });
            yInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleAddPoint(); });

            pointsListContainer.addEventListener('click', (e) => {
                if (e.target.closest('.delete-point-btn')) {
                    const index = parseInt(e.target.closest('.delete-point-btn').dataset.index, 10);
                    points.splice(index, 1);
                    updatePointsList();
                    drawGraph();
                }
            });

            connectDotsToggle.addEventListener('click', () => {
                connectDots = !connectDots;
                const span = connectDotsToggle.querySelector('span');
                if (connectDots) {
                    connectDotsToggle.setAttribute('aria-checked', 'true');
                    connectDotsToggle.classList.remove('bg-slate-300');
                    connectDotsToggle.classList.add('bg-blue-600');
                    span.style.transform = 'translateX(20px)';
                } else {
                    connectDotsToggle.setAttribute('aria-checked', 'false');
                    connectDotsToggle.classList.remove('bg-blue-600');
                    connectDotsToggle.classList.add('bg-slate-300');
                    span.style.transform = 'translateX(0)';
                }
                drawGraph();
            });

            invertValuesBtn.addEventListener('click', () => {
                points = points.map(p => ({ x: -p.x, y: -p.y }));
                updatePointsList();
                drawGraph();
            });

            clearGraphBtn.addEventListener('click', () => {
                points = [];
                updatePointsList();
                drawGraph();
            });

            exportPngBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'graph.png';
                // Captures the current high-resolution state of the canvas
                link.href = canvas.toDataURL('image/png');
                link.click();
            });

            exportJpgBtn.addEventListener('click', () => {
                // To export as JPG, we need to fill the background as JPG doesn't support transparency
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;

                // Fill background with the same color as the graph area
                tempCtx.fillStyle = '#f8fafc'; // slate-50
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                // Draw the current canvas content onto the temp canvas
                tempCtx.drawImage(canvas, 0, 0);

                // Trigger download
                const link = document.createElement('a');
                link.download = 'graph.jpg';
                link.href = tempCanvas.toDataURL('image/jpeg', 0.9); // 0.9 quality
                link.click();
            });

            // --- Panning Logic (Scroll/Drag) ---
            canvasContainer.addEventListener('mousedown', (e) => {
                // Only start dragging with the left mouse button (0)
                if (e.button === 0) {
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvasContainer.classList.add('dragging');
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    canvasContainer.classList.remove('dragging');
                }
            });

            document.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Tooltip logic
                const graphX = fromCanvasX(mouseX).toFixed(2);
                const graphY = fromCanvasY(mouseY).toFixed(2);
                coordsTooltip.style.display = 'block';
                coordsTooltip.style.left = `${mouseX + 15}px`;
                coordsTooltip.style.top = `${mouseY + 15}px`;
                coordsTooltip.textContent = `(${graphX}, ${graphY})`;

                // Panning logic
                if (isDragging) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;

                    originX += dx;
                    originY += dy;

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;

                    drawGraph();
                }

                // Hover logic
                let foundPoint = false;
                if (!isDragging) { // Avoid hovering while actively dragging
                    for (let i = 0; i < points.length; i++) {
                        const canvasX = toCanvasX(points[i].x);
                        const canvasY = toCanvasY(points[i].y);
                        const distance = Math.sqrt((mouseX - canvasX) ** 2 + (mouseY - canvasY) ** 2);
                        if (distance < 8) { // Hover radius
                            if (hoveredPointIndex !== i) {
                                hoveredPointIndex = i;
                                drawGraph();
                            }
                            foundPoint = true;
                            break;
                        }
                    }
                }

                if (!foundPoint && hoveredPointIndex !== -1) {
                    hoveredPointIndex = -1;
                    drawGraph();
                }
            });
            
            canvasContainer.addEventListener('mouseleave', () => {
                coordsTooltip.style.display = 'none';
                if (isDragging) {
                    isDragging = false;
                    canvasContainer.classList.remove('dragging');
                }
            });


            // --- Display Settings Listeners (Axis checks and limits) ---
            showPosXCheck.addEventListener('change', () => { showPosX = showPosXCheck.checked; drawGraph(); });
            showNegXCheck.addEventListener('change', () => { showNegX = showNegXCheck.checked; drawGraph(); });
            showPosYCheck.addEventListener('change', () => { showPosY = showPosYCheck.checked; drawGraph(); });
            showNegYCheck.addEventListener('change', () => { showNegY = showNegYCheck.checked; drawGraph(); });
            showNumbersCheck.addEventListener('change', () => { showNumbers = showNumbersCheck.checked; drawGraph(); });

            labelFrequencyInput.addEventListener('change', () => {
                const freq = parseInt(labelFrequencyInput.value, 10);
                if (!isNaN(freq) && freq > 0) {
                    labelFrequency = freq;
                    drawGraph();
                }
            });

            // Helper function for axis limit inputs
            function createAxisLimitListener(inputElement, stateKey) {
                inputElement.addEventListener('change', () => {
                    const value = parseFloat(inputElement.value);
                    if (!isNaN(value) && value > 0) {
                        // All keys store the POSITIVE magnitude of the limit
                        window[stateKey] = value;
                    } else {
                        window[stateKey] = null;
                    }
                    drawGraph();
                });
            }

            createAxisLimitListener(maxPosXInput, 'manualMaxPosX');
            createAxisLimitListener(maxNegXInput, 'manualMaxNegX');
            createAxisLimitListener(maxPosYInput, 'manualMaxPosY');
            createAxisLimitListener(maxNegYInput, 'manualMaxNegY');


            // --- Fullscreen Logic ---
            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    // Entering fullscreen
                    appContainer.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else {
                    // Exiting fullscreen
                    document.exitFullscreen();
                }
            });

            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement) {
                    fullscreenIcon.textContent = 'fullscreen_exit';
                } else {
                    fullscreenIcon.textContent = 'fullscreen';
                }
                // Recalculate canvas size and reposition origin on fullscreen change
                resizeCanvas();
            });

            // --- Initialization ---
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            updatePointsList();
            updateScale(currentZoomPercent); // Apply initial zoom
        });
    </script>
    <script>
(() => {
  // Updated Storage Key for Graph Maker
  const STORAGE_KEY = "docuwritepro_graph_maker_guide_seen";
  if (localStorage.getItem(STORAGE_KEY)) return;

  const tips = [
    "Welcome to the Interactive Graph Maker! Start by entering X and Y values in the 'Add a Point' section to plot data.",
    "Click and drag anywhere on the graph area to pan the view. Your coordinates are tracked by the floating tooltip.",
    "Toggle 'Connect Points' in the Actions panel to draw lines between your plotted points in the order they were added.",
    "Use the Zoom Level input to scale the grid. You can go from a bird's-eye view down to detailed precision.",
    "The Display Settings allow you to toggle individual axes (+X, -X, +Y, -Y) or hide the grid numbers entirely.",
    "Need custom boundaries? Enter magnitudes in the 'Max' fields to manually constrain how far the axes extend.",
    "Adjust the 'Label every' frequency to change how often numbers appear on the axes (e.g., every 5 or 10 units).",
    "Use the 'Invert' button to quickly flip all your plotted coordinates across both the X and Y axes.",
    "Click the Fullscreen icon in the Actions header to expand the graph area for a better design experience.",
    "Ready to share? Export your final graph as a high-resolution PNG or JPG directly to your device."
  ];

  let index = 0;
  let direction = 1;

  /* Container */
  const box = document.createElement("div");
  box.id = "dwp-tip-box";
  box.innerHTML = `
    <div class="dwp-progress">
      <div class="dwp-progress-bar"></div>
    </div>

    <div class="dwp-tip-wrapper">
      <div class="dwp-tip-text"></div>
    </div>

    <div class="dwp-actions">
      <button class="dwp-prev">Back</button>
      <button class="dwp-next">Next</button>
    </div>
  `;
  document.body.appendChild(box);

  const textEl = box.querySelector(".dwp-tip-text");
  const nextBtn = box.querySelector(".dwp-next");
  const prevBtn = box.querySelector(".dwp-prev");
  const progressBar = box.querySelector(".dwp-progress-bar");

  function updateTip(animate = true) {
    if (animate) {
      textEl.classList.remove("slide-in-left", "slide-in-right");
      void textEl.offsetWidth;
      textEl.classList.add(direction > 0 ? "slide-in-right" : "slide-in-left");
    }

    textEl.textContent = tips[index];
    progressBar.style.width = `${((index + 1) / tips.length) * 100}%`;

    prevBtn.style.visibility = index === 0 ? "hidden" : "visible";
    nextBtn.textContent = index === tips.length - 1 ? "Got it" : "Next";
  }

  nextBtn.onclick = () => {
    if (index === tips.length - 1) {
      localStorage.setItem(STORAGE_KEY, "true");
      box.classList.add("fade-out");
      setTimeout(() => box.remove(), 300);
    } else {
      direction = 1;
      index++;
      updateTip();
    }
  };

  prevBtn.onclick = () => {
    if (index > 0) {
      direction = -1;
      index--;
      updateTip();
    }
  };

  setTimeout(() => {
    box.classList.add("show");
    updateTip(false);
  }, 1000);

  /* Styles */
  const style = document.createElement("style");
  style.textContent = `
    #dwp-tip-box {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 320px;
      background: #2563eb; /* Blue-600 to match Graph Maker theme */
      color: #fff;
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 35px rgba(0,0,0,.2);
      font-family: 'Inter', system-ui, sans-serif;
      z-index: 99999;
      opacity: 0;
      transform: translateY(10px);
      transition: opacity .3s ease, transform .3s ease;
    }

    #dwp-tip-box.show {
      opacity: 1;
      transform: translateY(0);
    }

    #dwp-tip-box.fade-out {
      opacity: 0;
      transform: translateY(10px);
    }

    .dwp-progress {
      height: 4px;
      background: rgba(255,255,255,.25);
      border-radius: 99px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .dwp-progress-bar {
      height: 100%;
      width: 0%;
      background: #fff;
      transition: width .35s ease;
    }

    .dwp-tip-wrapper {
      overflow: hidden;
      min-height: 54px;
      display: flex;
      align-items: center;
    }

    .dwp-tip-text {
      font-size: 14px;
      line-height: 1.5;
    }

    .slide-in-right {
      animation: slideRight .25s ease;
    }

    .slide-in-left {
      animation: slideLeft .25s ease;
    }

    @keyframes slideRight {
      from { opacity: 0; transform: translateX(14px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes slideLeft {
      from { opacity: 0; transform: translateX(-14px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .dwp-actions {
      display: flex;
      justify-content: space-between;
      margin-top: 14px;
    }

    .dwp-actions button {
      border: none;
      padding: 6px 14px;
      border-radius: 7px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .dwp-actions button:hover {
      opacity: 0.9;
    }

    .dwp-prev {
      background: rgba(255,255,255,.2);
      color: #fff;
    }

    .dwp-next {
      background: #fff;
      color: #2563eb;
    }
  `;
  document.head.appendChild(style);
})();
    </script>
</body>
</html>
