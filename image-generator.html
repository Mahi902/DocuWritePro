<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Image Generator</title>
  <meta name="description" content="DocuWrite Pro is an all-in-one online workspace that lets you write, edit, convert, design, and manage documents and digital content instantly‚Äîno installation, no complexity.">
¬† <meta name="keywords" content="DocuWrite Pro, Mohtadi Azad Mahi, AI writer, document editor, online text tool, GitHub project, DocuWritePro, Document Editor, Document, Editor, PDF, JPG, Edit, Text, Change File Type, File Changer, Format, Format Changer, Office, Docs, A4, Editor, General document editing, Collab, Editing documents together, Document Viewer, Viewing documents, Word Finder, Searching for specific words, Translator, Language translation, Document Signer, Electronically signing documents, Page Number Adder, Adding page numbers to documents, Chart Maker, Creating data charts, Table Maker, Creating tables, Watermark Adder, Adding watermarks to files, Email Writer, Assisting with writing emails, Spell Checker, Checking spelling and grammar, File Extractor, Extracting contents from files, QR Maker, Creating QR codes, ID Card Maker, Designing and creating ID cards, File Zipper, Compressing or zipping files, PDF Converter, Converting files to or from PDF format, Context Field, Analyzing text (e.g., word count, frequency), Gift Card Maker, Creating custom gift cards, Share File, Uploading or sharing a file, Text Extractor, Extracting text from sources (e.g., images), Keyboard Click Test, Testing keyboard functionality, Frontend IDE, Integrated Development Environment for frontend coding, HTML Editor, Editing HTML code, HTML Writer, Writing or generating HTML content, Button Designer, Designing user interface buttons, HTML Splitter, Splitting HTML files or elements, GoTo Code, Navigation feature in an IDE/editor, Code Snipper, Storing or managing code snippets, Image Editor, Editing images, Image Generator, Generating new images, Drawing Board, A simple drawing or sketching tool, HTML, CSS, JS, Online, Fast, Easy, No login, No signup, Free, No credit card required, Mohtadi, Azad, Mahi, Mohtadi Azad, Mohtadi Azad Mahi, mahi902">
¬† <meta name="author" content="Mohtadi Azad Mahi">
¬† <meta name="robots" content="index, follow">

¬† <!-- Favicon & App Icons -->
¬† <link rel="icon" type="image/png" sizes="16x16" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
¬† <link rel="icon" type="image/png" sizes="32x32" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
¬† <link rel="icon" type="image/png" sizes="192x192" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
¬† <link rel="apple-touch-icon" href="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">
¬† <meta name="theme-color" content="#ffffff">

¬† <!-- App & Brand Metadata -->
¬† <meta property="og:site_name" content="DocuWrite Pro">
¬† <meta name="application-name" content="DocuWrite Pro">
¬† <meta name="apple-mobile-web-app-title" content="DocuWrite Pro">

¬† <!-- Open Graph -->
¬† <meta property="og:title" content="DocuWrite Pro ‚Äî Online Document Editor">
¬† <meta property="og:description" content="Edit, format, and export documents easily with DocuWrite Pro by Mohtadi Azad Mahi.">
¬† <meta property="og:url" content="https://mahi902.github.io/DocuWritePro/">
¬† <meta property="og:type" content="website">
¬† <meta property="og:image" content="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">

¬† <!-- Twitter Cards -->
¬† <meta name="twitter:card" content="summary_large_image">
¬† <meta name="twitter:title" content="DocuWrite Pro ‚Äî Online Document Editor">
¬† <meta name="twitter:description" content="Create, format, and export documents easily with DocuWrite Pro. Built by Mohtadi Azad Mahi.">
¬† <meta name="twitter:image" content="https://i.ibb.co.com/k2QvnvMz/IMG-20251010-111934.jpg">

¬† <!-- Structured Data (Google Knowledge Graph) -->
¬† <script type="application/ld+json">
¬† {
¬† ¬† "@context": "https://schema.org",
¬† ¬† "@type": "WebSite",
¬† ¬† "name": "DocuWrite Pro",
¬† ¬† "alternateName": "DocuWrite Pro ‚Äî Online Document Editor",
¬† ¬† "url": "https://mahi902.github.io/DocuWritePro/",
¬† ¬† "creator": {
¬† ¬† ¬† "@type": "Person",
¬† ¬† ¬† "name": "Mohtadi Azad Mahi"
¬† ¬† }
¬† }
  </script>
  <link rel="stylesheet" href="https://public.codepenassets.com/css/reset-2.0.min.css">
<link rel="stylesheet" href="./style.css">
<style>
@charset "UTF-8";
/* ===== CSS Variables & Base Setup ===== */
:root {
  /* Colors */
  --color-bg-primary: #ffffff;
  --color-bg-secondary: #f8f9fa;
  --color-bg-tertiary: #f1f3f4;
  --color-text-primary: #1a1a1a;
  --color-text-secondary: #666666;
  --color-text-muted: #999999;
  --color-border: #e1e5e9;
  --color-border-focus: #4285f4;
  --color-accent: #4285f4;
  --color-accent-hover: #3367d6;
  --color-success: #34a853;
  --color-warning: #fbbc04;
  --color-error: #ea4335;
  --color-shadow: rgba(0, 0, 0, 0.1);
  --color-shadow-hover: rgba(0, 0, 0, 0.15);
  /* Spacing & Layout */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;
  --spacing-xxl: 48px;
  /* Border Radius */
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  /* Transitions */
  --transition-fast: 0.15s ease;
  --transition-medium: 0.25s ease;
  --transition-slow: 0.35s ease;
  /* Z-index Scale */
  --z-header: 100;
  --z-settings: 200;
  --z-modal: 300;
}

/* ===== Base Styles ===== */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
  background-color: var(--color-bg-primary);
  color: var(--color-text-primary);
  line-height: 1.5;
  transition: background-color var(--transition-medium), color var(--transition-medium);
  overflow-x: hidden;
}

/* ===== App Container ===== */
.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ===== App Header (Logo + Sidebar Toggle Only) ===== */
.app-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: calc(var(--z-header) + 1);
  background-color: var(--color-bg-secondary);
  border-bottom: 1px solid var(--color-border);
  padding: var(--spacing-md) var(--spacing-lg);
  display: flex;
  align-items: center;
  gap: var(--spacing-md);
  backdrop-filter: blur(10px);
  height: 60px;
}

.sidebar-toggle {
  background-color: var(--color-bg-primary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--spacing-sm);
  cursor: pointer;
  transition: all var(--transition-fast);
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px var(--color-shadow);
}

.sidebar-toggle:hover {
  background-color: var(--color-bg-tertiary);
  border-color: var(--color-accent);
  transform: scale(1.05);
}

.app-title {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--color-text-primary);
  margin: 0;
}

.hamburger-icon {
  display: flex;
  flex-direction: column;
  width: 16px;
  height: 12px;
  justify-content: space-between;
}

.hamburger-icon span {
  display: block;
  height: 2px;
  width: 100%;
  background-color: var(--color-text-secondary);
  border-radius: 1px;
  transition: all var(--transition-fast);
}

.settings.is-open ~ .sidebar-toggle .hamburger-icon span:nth-child(1) {
  transform: rotate(45deg) translate(4px, 4px);
}

.settings.is-open ~ .sidebar-toggle .hamburger-icon span:nth-child(2) {
  opacity: 0;
}

.settings.is-open ~ .sidebar-toggle .hamburger-icon span:nth-child(3) {
  transform: rotate(-45deg) translate(5px, -5px);
}

/* ===== Main Layout ===== */
.main {
  flex: 1;
  display: flex;
  position: relative;
  max-width: 100%;
  margin: 0;
  width: 100%;
  padding-top: 60px;
  /* Account for app-header */
}

/* ===== Settings Panel ===== */
.settings {
  width: 320px;
  min-width: 320px;
  background-color: var(--color-bg-secondary);
  border-right: 1px solid var(--color-border);
  position: fixed;
  top: 60px;
  left: 0;
  bottom: 0;
  transform: translateX(-100%);
  transition: transform var(--transition-medium);
  z-index: var(--z-settings);
  overflow-y: auto;
}

.settings.is-open {
  transform: translateX(0);
}

.settings_header {
  padding: var(--spacing-lg);
  border-bottom: 1px solid var(--color-border);
  position: sticky;
  top: 0;
  background-color: var(--color-bg-secondary);
  z-index: 10;
}

.settings_header h2 {
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--color-text-primary);
}

.settings_content {
  padding: var(--spacing-lg);
}

.setting-group {
  margin-bottom: var(--spacing-lg);
}

.setting-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
}

.setting-group label {
  display: block;
  font-size: 0.875rem;
  font-weight: 500;
  color: var(--color-text-secondary);
  margin-bottom: var(--spacing-xs);
}

.setting-input {
  width: 100%;
  padding: var(--spacing-sm) var(--spacing-md);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  background-color: var(--color-bg-primary);
  color: var(--color-text-primary);
  font-size: 0.875rem;
  transition: all var(--transition-fast);
}

.setting-input:focus {
  outline: none;
  border-color: var(--color-border-focus);
  box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
}

.setting-slider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--color-bg-tertiary);
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.setting-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--color-accent);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.setting-slider::-webkit-slider-thumb:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 8px var(--color-shadow);
}

.setting-slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--color-accent);
  cursor: pointer;
  border: none;
  transition: all var(--transition-fast);
}

.setting-slider::-moz-range-thumb:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 8px var(--color-shadow);
}

/* ===== Refinement Section ===== */
.refinement-section {
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-lg);
  background-color: var(--color-bg-primary);
}

.refinement-section h3 {
  font-size: 1rem;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: var(--spacing-md);
}

.refine-button {
  width: 100%;
  background: linear-gradient(135deg, var(--color-accent), var(--color-accent-hover));
  color: white;
  border: none;
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--spacing-xs);
}

.refine-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px var(--color-shadow-hover);
}

.refine-button.is-loading {
  opacity: 0.8;
  cursor: not-allowed;
}

.refine-button.is-loading span:first-child {
  animation: spin 1s linear infinite;
}

.checkbox-label {
  display: flex !important;
  align-items: center;
  cursor: pointer;
  margin-bottom: 0 !important;
}

.checkbox-label input[type=checkbox] {
  display: none;
}

.checkbox-custom {
  width: 18px;
  height: 18px;
  border: 2px solid var(--color-border);
  border-radius: var(--radius-sm);
  margin-right: var(--spacing-sm);
  position: relative;
  transition: all var(--transition-fast);
}

.checkbox-label input[type=checkbox]:checked + .checkbox-custom {
  background-color: var(--color-accent);
  border-color: var(--color-accent);
}

.checkbox-label input[type=checkbox]:checked + .checkbox-custom::after {
  content: "‚úì";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 12px;
  font-weight: bold;
}

/* ===== Workspace ===== */
.workspace {
  flex: 1;
  padding: var(--spacing-lg);
  transition: margin-left var(--transition-medium);
  display: flex;
  flex-direction: column;
  height: calc(100vh - 60px);
}

.settings.is-open ~ .workspace {
  margin-left: 320px;
}

/* ===== Gallery Container (Scrollable) ===== */
.gallery-container {
  flex: 1;
  overflow-y: auto;
  padding-right: var(--spacing-sm);
  margin-bottom: var(--spacing-lg);
}

.gallery-container::-webkit-scrollbar {
  width: 8px;
}

.gallery-container::-webkit-scrollbar-track {
  background: var(--color-bg-tertiary);
  border-radius: 4px;
}

.gallery-container::-webkit-scrollbar-thumb {
  background: var(--color-border);
  border-radius: 4px;
  transition: background var(--transition-fast);
}

.gallery-container::-webkit-scrollbar-thumb:hover {
  background: var(--color-text-muted);
}

/* ===== Fixed Prompt Area ===== */
.prompt-area {
  background-color: var(--color-bg-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  padding: var(--spacing-md);
  position: sticky;
  bottom: 0;
  z-index: 50;
  box-shadow: 0 -4px 20px var(--color-shadow);
}

.prompt-controls {
  display: flex;
  gap: var(--spacing-md);
  align-items: flex-end;
}

/* ===== Prompt Input Styles ===== */
.prompt-input {
  flex: 1;
  padding: var(--spacing-md);
  border: 2px solid var(--color-border);
  border-radius: var(--radius-lg);
  background-color: var(--color-bg-primary);
  color: var(--color-text-primary);
  font-size: 1rem;
  resize: vertical;
  min-height: 60px;
  max-height: 120px;
  transition: all var(--transition-fast);
  font-family: inherit;
  line-height: 1.5;
}

.prompt-input:focus {
  outline: none;
  border-color: var(--color-border-focus);
  box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.1);
}

.generate-button {
  background: linear-gradient(135deg, var(--color-accent), var(--color-accent-hover));
  color: white;
  border: none;
  border-radius: var(--radius-lg);
  padding: var(--spacing-md) var(--spacing-xl);
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
  min-width: 160px;
  justify-content: center;
}

.generate-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px var(--color-shadow-hover);
}

.generate-button:active {
  transform: translateY(0);
}

.generate-button.is-loading {
  opacity: 0.8;
  cursor: not-allowed;
}

/* ===== Gallery ===== */
.gallery {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-xl);
}

/* ===== Image Cards ===== */
.image-card {
  background-color: var(--color-bg-secondary);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-lg);
  overflow: hidden;
  transition: all var(--transition-medium);
}

.image-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 24px var(--color-shadow-hover);
}

.image-card_content {
  position: relative;
  aspect-ratio: 1;
  overflow: hidden;
  cursor: pointer;
}

.image-card_content:hover .image-card_image {
  transform: scale(1.02);
}

.image-card_placeholder {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: var(--color-bg-tertiary);
  gap: var(--spacing-md);
}

.image-card_image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform var(--transition-medium);
}

.status-text {
  font-size: 0.875rem;
  color: var(--color-text-secondary);
  font-weight: 500;
}

/* Status Colors */
.image-card[data-status=pending] .status-text {
  color: var(--color-warning);
}

.image-card[data-status=rendering] .status-text {
  color: var(--color-accent);
}

.image-card[data-status=completed] .status-text {
  color: var(--color-success);
}

.image-card[data-status=error] .status-text {
  color: var(--color-error);
}

.image-card_info {
  padding: var(--spacing-md);
}

.image-card_prompt {
  font-size: 0.875rem;
  color: var(--color-text-primary);
  margin-bottom: var(--spacing-sm);
  line-height: 1.4;
  max-height: 2.8em;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.image-card_meta {
  display: flex;
  justify-content: space-between;
  gap: var(--spacing-sm);
}

.meta-item {
  font-size: 0.75rem;
  color: var(--color-text-muted);
}

.image-card_actions {
  padding: var(--spacing-md);
  display: flex;
  gap: var(--spacing-sm);
  border-top: 1px solid var(--color-border);
}

.card-action {
  flex: 1;
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  background-color: var(--color-bg-primary);
  color: var(--color-text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-size: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

.card-action:hover {
  background-color: var(--color-bg-tertiary);
  color: var(--color-text-primary);
}

.retry-button:hover {
  background-color: var(--color-warning);
  color: white;
  border-color: var(--color-warning);
}

.download-button:hover {
  background-color: var(--color-success);
  color: white;
  border-color: var(--color-success);
}

.remove-button:hover {
  background-color: var(--color-error);
  color: white;
  border-color: var(--color-error);
}

/* ===== Empty State ===== */
.empty-state {
  text-align: center;
  padding: var(--spacing-xxl);
  color: var(--color-text-secondary);
}

.empty-state.is-hidden {
  display: none;
}

.empty-state_icon {
  font-size: 4rem;
  margin-bottom: var(--spacing-lg);
}

.empty-state_title {
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: var(--spacing-sm);
  color: var(--color-text-primary);
}

.empty-state_description {
  font-size: 1rem;
  max-width: 400px;
  margin: 0 auto;
  line-height: 1.6;
}

/* ===== Loader Animation ===== */
.loader {
  width: 40px;
  height: 40px;
  border: 3px solid var(--color-border);
  border-top: 3px solid var(--color-accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
/* ===== Fullscreen Image Modal ===== */
.fullscreen-modal {
  position: fixed;
  inset: 0;
  z-index: var(--z-modal);
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: all var(--transition-medium);
}

.fullscreen-modal.is-open {
  opacity: 1;
  visibility: visible;
}

.fullscreen-backdrop {
  position: absolute;
  inset: 0;
  background-color: rgba(30, 30, 30, 0.8);
  backdrop-filter: blur(5px);
}

.fullscreen-close {
  position: absolute;
  top: var(--spacing-lg);
  right: var(--spacing-lg);
  z-index: 10;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  border: none;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  font-size: 1.5rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all var(--transition-fast);
}

.fullscreen-close:hover {
  background-color: rgba(0, 0, 0, 0.9);
  transform: scale(1.1);
}

.fullscreen-content {
  position: relative;
  width: 100dvw;
  height: 100dvh;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-xl);
}

.fullscreen-image {
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain;
  border-radius: var(--radius-md);
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
}

.fullscreen-info {
  position: absolute;
  bottom: var(--spacing-lg);
  left: var(--spacing-lg);
  right: var(--spacing-lg);
  background-color: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(10px);
  border-radius: var(--radius-md);
  padding: var(--spacing-md);
  color: white;
}

.fullscreen-prompt-section h4 {
  margin: 0 0 var(--spacing-sm) 0;
  font-size: 0.875rem;
  font-weight: 600;
  color: #cccccc;
}

.fullscreen-prompt {
  margin: 0 0 var(--spacing-md) 0;
  font-size: 0.875rem;
  line-height: 1.4;
  color: white;
  max-height: 60px;
  overflow-y: auto;
}

.copy-prompt-button {
  background: var(--color-accent);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: var(--spacing-xs) var(--spacing-sm);
  font-size: 0.75rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: all var(--transition-fast);
}

.copy-prompt-button:hover {
  background: var(--color-accent-hover);
  transform: translateY(-1px);
}

/* ===== Responsive Design ===== */
@media (max-width: 768px) {
  .app-header {
    padding: var(--spacing-sm) var(--spacing-md);
  }

  .workspace {
    padding: var(--spacing-md);
  }

  .settings {
    width: 100vw;
    max-width: 100vw;
  }

  .settings.is-open ~ .workspace {
    margin-left: 0;
  }

  .prompt-controls {
    flex-direction: column;
    gap: var(--spacing-sm);
  }

  .generate-button {
    min-width: auto;
    width: 100%;
  }

  .gallery {
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: var(--spacing-md);
  }

  .setting-row {
    grid-template-columns: 1fr;
  }

  .fullscreen-content {
    padding: var(--spacing-md);
  }

  .fullscreen-info {
    bottom: var(--spacing-sm);
    left: var(--spacing-sm);
    right: var(--spacing-sm);
    padding: var(--spacing-sm);
  }
}
</style>
</head>
<body>
<!-- partial:index.partial.html -->
<!-- CodePen HTML Section -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<div class="app">
    <!-- Logo + Sidebar Toggle (No Header) -->
    <div class="app-header">
        <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle sidebar">
            <span class="hamburger-icon">
                <span></span>
                <span></span>
                <span></span>
            </span>
        </button>
        <h1 class="app-title">Image Generator</h1>
    </div>

    <!-- Main Content -->
    <main class="main">
        <!-- Settings Panel -->
        <aside class="settings" id="settingsPanel">
            <div class="settings_header">
                <h2>Generation Settings</h2>
            </div>
            
            <div class="settings_content">
                <div class="setting-group">
                    <label for="imageModelSelect">Image Model</label>
                    <select id="imageModelSelect" class="setting-input">
                        <option value="flux">Loading models...</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="textModelSelect">Text Model (for prompt refinement)</label>
                    <select id="textModelSelect" class="setting-input">
                        <option value="openai">Loading models...</option>
                    </select>
                </div>

                <div class="setting-row">
                    <div class="setting-group">
                        <label for="widthInput">Width</label>
                        <input type="number" id="widthInput" class="setting-input" value="1024" min="256" max="2048" step="64">
                    </div>
                    <div class="setting-group">
                        <label for="heightInput">Height</label>
                        <input type="number" id="heightInput" class="setting-input" value="1024" min="256" max="2048" step="64">
                    </div>
                </div>

                <div class="setting-row">
                    <div class="setting-group">
                        <label for="batchCountInput">Batch Size</label>
                        <input type="number" id="batchCountInput" class="setting-input" value="4" min="1" max="20">
                    </div>
                    <div class="setting-group">
                        <label for="seedInput">Base Seed</label>
                        <input type="number" id="seedInput" class="setting-input" value="-1" min="-1">
                    </div>
                </div>

                <div class="setting-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="nologoCheckbox" checked>
                        <span class="checkbox-custom"></span>
                        No Logo
                    </label>
                </div>

                <!-- Prompt Refinement Section -->
                <div class="refinement-section">
                    <h3>Prompt Refiner</h3>
                    
                    <div class="setting-group">
                        <label for="targetWordsSlider">Target Length: <span id="targetWordsValue">50</span> words</label>
                        <input type="range" id="targetWordsSlider" class="setting-slider" min="5" max="300" value="50">
                    </div>

                    <div class="setting-group">
                        <label for="refinementInstructions">Custom Instructions</label>
                        <textarea id="refinementInstructions" class="setting-input" rows="2" placeholder="e.g., Focus on lighting and composition..."></textarea>
                    </div>

                    <div class="setting-group">
                        <button class="refine-button" id="refineButton" title="Refine prompt to target length">
                            <span>‚ú®</span>
                            <span>Refine Prompt</span>
                        </button>
                    </div>
                </div>

                <div class="setting-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="autoDownloadCheckbox">
                        <span class="checkbox-custom"></span>
                        Auto Download
                    </label>
                </div>
            </div>
        </aside>

        <!-- Generation Area -->
        <section class="workspace">
            <!-- Image Gallery (Scrollable) -->
            <div class="gallery-container">
                <div class="gallery" id="imageGallery">
                    <!-- Images will be populated here -->
                </div>

                <!-- Empty State -->
                <div class="empty-state" id="emptyState">                    <h3 class="empty-state_title">Ready to Create</h3>
                    <p class="empty-state_description">Enter a prompt below and click Generate to start creating amazing images</p>
                </div>
            </div>

            <!-- Fixed Prompt Area -->
            <div class="prompt-area">
                <div class="prompt-controls">
                    <textarea id="mainPromptInput" class="prompt-input" placeholder="Describe the image you want to generate..." rows="2"></textarea>
                    <button id="generateButton" class="generate-button">
                        <span class="generate-button_text">Generate</span></span>
                    </button>
                </div>
            </div>
        </section>
    </main>

    <!-- Fullscreen Image Modal -->
    <div class="fullscreen-modal" id="fullscreenModal">
        <div class="fullscreen-backdrop"></div>
        <button class="fullscreen-close" id="fullscreenClose" aria-label="Close fullscreen">√ó</button>
        <div class="fullscreen-content">
            <img class="fullscreen-image" id="fullscreenImage" alt="Fullscreen view">
        </div>
        <div class="fullscreen-info">
            <div class="fullscreen-prompt-section">
                <h4>Generated Prompt:</h4>
                <p class="fullscreen-prompt" id="fullscreenPrompt"></p>
                <button class="copy-prompt-button" id="copyPromptButton">
                    <span>üìã</span>
                    Copy Prompt
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Image Card Template -->
<template id="imageCardTemplate">
    <div class="image-card" data-status="pending">
        <div class="image-card_content">
            <div class="image-card_placeholder">
                <div class="loader"></div>
                <div class="status-text">Pending</div>
            </div>
            <img class="image-card_image" alt="Generated image" style="display: none;">
        </div>
        
        <div class="image-card_info">
            <div class="image-card_prompt"></div>
            <div class="image-card_meta">
                <span class="meta-item seed">Seed: <span class="seed-value">-</span></span>
                <span class="meta-item model">Model: <span class="model-value">-</span></span>
            </div>
        </div>
        
        <div class="image-card_actions">
            <button class="card-action retry-button" style="display: none;">
                <span>üîÑ</span>
                Retry
            </button>
            <button class="card-action download-button" style="display: none;">
                <span>‚¨áÔ∏è</span>
                Download
            </button>
            <button class="card-action remove-button">
                <span>üóëÔ∏è</span>
                Remove
            </button>
        </div>
    </div>
</template>
<!-- partial -->
  <script  src="./script.js"></script>
<script>
/**
 * PoliUI Studio - Professional Image Generation Interface
 * Uses latest Pollinations.AI API with queue management
 */

class PolliStudio {
    constructor() {
        this.API_BASE = 'https://image.pollinations.ai';
        this.MODELS_ENDPOINT = 'https://image.pollinations.ai/models';
        this.TEXT_MODELS_ENDPOINT = 'https://text.pollinations.ai/models';
        this.TEXT_API = 'https://text.pollinations.ai/openai';
        
        // Queue management
        this.imageQueue = [];
        this.activeRenders = new Set();
        this.maxConcurrentRenders = 3;
        this.currentImageId = 0;
        
        // Fullscreen navigation
        this.currentFullscreenIndex = 0;
        this.fullscreenImages = [];
        
        // Cache
        this.availableImageModels = [];
        this.availableTextModels = [];
        this.settings = this.loadSettings();
        this.originalPrompts = new Map(); // Store original prompts
        
        // DOM elements
        this.elements = {};
        
        this.init();
    }

    /**
     * Initialize the application
     */
    async init() {
        this.cacheElements();
        this.bindEvents();
        await this.loadModels();
        this.restoreSettings();
        this.updateUI();
        
        console.log('PoliUI Studio initialized');
    }

    /**
     * Cache DOM elements for performance
     */
    cacheElements() {
        this.elements = {
            // Sidebar & Settings
            sidebarToggle: document.getElementById('sidebarToggle'),
            settingsPanel: document.getElementById('settingsPanel'),
            
            // Settings inputs
            imageModelSelect: document.getElementById('imageModelSelect'),
            textModelSelect: document.getElementById('textModelSelect'),
            widthInput: document.getElementById('widthInput'),
            heightInput: document.getElementById('heightInput'),
            batchCountInput: document.getElementById('batchCountInput'),
            seedInput: document.getElementById('seedInput'),
            nologoCheckbox: document.getElementById('nologoCheckbox'),
            autoDownloadCheckbox: document.getElementById('autoDownloadCheckbox'),
            targetWordsSlider: document.getElementById('targetWordsSlider'),
            targetWordsValue: document.getElementById('targetWordsValue'),
            refinementInstructions: document.getElementById('refinementInstructions'),
            refineButton: document.getElementById('refineButton'),
            
            // Main interface
            mainPromptInput: document.getElementById('mainPromptInput'),
            generateButton: document.getElementById('generateButton'),
            
            // Gallery
            imageGallery: document.getElementById('imageGallery'),
            emptyState: document.getElementById('emptyState'),
            
            // Fullscreen modal
            fullscreenModal: document.getElementById('fullscreenModal'),
            fullscreenImage: document.getElementById('fullscreenImage'),
            fullscreenClose: document.getElementById('fullscreenClose'),
            fullscreenPrompt: document.getElementById('fullscreenPrompt'),
            copyPromptButton: document.getElementById('copyPromptButton'),
            
            // Template
            imageCardTemplate: document.getElementById('imageCardTemplate')
        };
    }

    /**
     * Bind event listeners
     */
    bindEvents() {
        // Sidebar toggle
        this.elements.sidebarToggle.addEventListener('click', () => this.toggleSettings());
        
        // Word count slider
        this.elements.targetWordsSlider.addEventListener('input', () => {
            this.elements.targetWordsValue.textContent = this.elements.targetWordsSlider.value;
        });
        
        // Prompt refinement
        this.elements.refineButton.addEventListener('click', () => this.refinePrompt());
        
        // Generation
        this.elements.generateButton.addEventListener('click', () => this.handleGenerate());
        this.elements.mainPromptInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                this.handleGenerate();
            }
        });
        
        // Fullscreen modal
        this.elements.fullscreenClose.addEventListener('click', () => this.closeFullscreen());
        this.elements.copyPromptButton.addEventListener('click', () => this.copyPromptToClipboard());
        this.elements.fullscreenModal.addEventListener('click', (e) => {
            if (e.target === this.elements.fullscreenModal || e.target.classList.contains('fullscreen-backdrop')) {
                this.closeFullscreen();
            }
        });
        
        // ESC key handler and arrow navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (this.elements.fullscreenModal.classList.contains('is-open')) {
                    this.closeFullscreen();
                } else if (this.elements.settingsPanel.classList.contains('is-open')) {
                    this.closeSettings();
                }
            }
            
            // Arrow navigation in fullscreen mode
            if (this.elements.fullscreenModal.classList.contains('is-open')) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    this.navigateFullscreen('prev');
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    this.navigateFullscreen('next');
                }
            }
        });
        
        // Settings auto-save
        Object.values(this.elements).forEach(element => {
            if (element && (element.type === 'checkbox' || element.type === 'number' || element.type === 'text' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA' || element.type === 'range')) {
                element.addEventListener('change', () => this.saveSettings());
            }
        });
        
        // Close settings when clicking outside (but not when clicking refine button)
        document.addEventListener('click', (e) => {
            if (!this.elements.settingsPanel.contains(e.target) && 
                !this.elements.sidebarToggle.contains(e.target) && 
                this.elements.settingsPanel.classList.contains('is-open') &&
                !this.elements.refineButton.contains(e.target)) {
                this.closeSettings();
            }
        });
    }

    /**
     * Load available models from Pollinations API
     */
    async loadModels() {
        await Promise.all([
            this.loadImageModels(),
            this.loadTextModels()
        ]);
    }

    /**
     * Load image models
     */
    async loadImageModels() {
        try {
            const response = await fetch(this.MODELS_ENDPOINT);
            if (!response.ok) throw new Error('Failed to fetch image models');
            
            const data = await response.json();
            this.availableImageModels = Array.isArray(data) ? data : data.data || [];
            this.populateImageModelSelect();
            
        } catch (error) {
            console.error('Error loading image models:', error);
            // Fallback to default models
            this.availableImageModels = ['flux', 'kontext', 'turbo', 'gptimage'];
            this.populateImageModelSelect();
        }
    }

    /**
     * Load text models
     */
    async loadTextModels() {
        try {
            const response = await fetch(this.TEXT_MODELS_ENDPOINT);
            if (!response.ok) throw new Error('Failed to fetch text models');
            
            const data = await response.json();
            this.availableTextModels = Array.isArray(data) ? data : data.data || [];
            this.populateTextModelSelect();
            
        } catch (error) {
            console.error('Error loading text models:', error);
            // Fallback to default models with proper fallback chain
            this.availableTextModels = [
                { name: 'openai', description: 'OpenAI GPT-4o Mini' },
                { name: 'mistral', description: 'Mistral Small' },
                { name: 'llamascout', description: 'Llama Scout' }
            ];
            this.populateTextModelSelect();
        }
    }

    /**
     * Populate image model select dropdown
     */
    populateImageModelSelect() {
        this.elements.imageModelSelect.innerHTML = '';
        
        this.availableImageModels.forEach(model => {
            const option = document.createElement('option');
            option.value = model.name || model;
            option.textContent = this.formatModelName(model.name || model);
            this.elements.imageModelSelect.appendChild(option);
        });
        
        // Restore saved model or default to flux
        const savedModel = this.settings.imageModel;
        const modelExists = this.availableImageModels.some(m => (m.name || m) === savedModel);
        if (savedModel && modelExists) {
            this.elements.imageModelSelect.value = savedModel;
        } else if (this.availableImageModels.length > 0) {
            // Default to flux if available, otherwise first model
            const fluxModel = this.availableImageModels.find(m => (m.name || m) === 'flux');
            this.elements.imageModelSelect.value = fluxModel ? (fluxModel.name || fluxModel) : (this.availableImageModels[0].name || this.availableImageModels[0]);
        }
    }

    /**
     * Populate text model select dropdown
     */
    populateTextModelSelect() {
        this.elements.textModelSelect.innerHTML = '';
        
        this.availableTextModels.forEach(model => {
            const option = document.createElement('option');
            const modelName = model.name || model;
            const modelDesc = model.description || this.formatModelName(modelName);
            
            option.value = modelName;
            option.textContent = `${this.formatModelName(modelName)} - ${modelDesc}`;
            this.elements.textModelSelect.appendChild(option);
        });
        
        // Set default with fallback chain: openai ‚Üí mistral ‚Üí llamascout ‚Üí first available
        const fallbackChain = ['openai', 'mistral', 'llamascout'];
        let defaultModel = null;
        
        for (const modelName of fallbackChain) {
            if (this.availableTextModels.some(m => (m.name || m) === modelName)) {
                defaultModel = modelName;
                break;
            }
        }
        
        if (!defaultModel && this.availableTextModels.length > 0) {
            defaultModel = this.availableTextModels[0].name || this.availableTextModels[0];
        }
        
        // Restore saved model if valid, otherwise use default
        const savedModel = this.settings.textModel;
        const modelExists = this.availableTextModels.some(m => (m.name || m) === savedModel);
        
        if (savedModel && modelExists) {
            this.elements.textModelSelect.value = savedModel;
        } else if (defaultModel) {
            this.elements.textModelSelect.value = defaultModel;
        }
    }

    /**
     * Format model name for display
     */
    formatModelName(model) {
        return model.replace(/[-_]/g, ' ')
                   .replace(/\b\w/g, l => l.toUpperCase());
    }

    /**
     * Handle generate button click
     */
    async handleGenerate() {
        const promptText = this.elements.mainPromptInput.value.trim();
        if (!promptText) {
            this.showNotification('Please enter a prompt', 'warning');
            return;
        }

        // Split by newlines and filter out empty lines
        const prompts = promptText.split('\n').filter(line => line.trim());
        
        if (prompts.length === 0) {
            this.showNotification('Please enter a valid prompt', 'warning');
            return;
        }

        const batchCount = parseInt(this.elements.batchCountInput.value) || 1;
        
        // Add images to queue for each prompt
        prompts.forEach((prompt, promptIndex) => {
            for (let i = 0; i < batchCount; i++) {
                this.queueImage(prompt.trim(), promptIndex * batchCount + i);
            }
        });
        
        this.updateUI();
        this.processQueue();
    }

    /**
     * Add image to generation queue
     */
    queueImage(prompt, index = 0) {
        const imageData = {
            id: ++this.currentImageId,
            prompt: prompt,
            model: this.elements.imageModelSelect.value,
            width: parseInt(this.elements.widthInput.value),
            height: parseInt(this.elements.heightInput.value),
            seed: this.generateSeed(index),
            nologo: this.elements.nologoCheckbox.checked,
            status: 'pending',
            retryCount: 0,
            maxRetries: 3
        };

        this.imageQueue.push(imageData);
        this.createImageCard(imageData);
    }

    /**
     * Generate seed for image
     */
    generateSeed(index = 0) {
        const baseSeed = parseInt(this.elements.seedInput.value);
        if (baseSeed === -1) {
            return Math.floor(Math.random() * 1000000);
        }
        return baseSeed + index;
    }

    /**
     * Process image generation queue
     */
    async processQueue() {
        while (this.imageQueue.length > 0 && this.activeRenders.size < this.maxConcurrentRenders) {
            const imageData = this.imageQueue.shift();
            this.activeRenders.add(imageData.id);
            this.renderImage(imageData);
        }
    }

    /**
     * Render single image
     */
    async renderImage(imageData) {
        try {
            this.updateImageStatus(imageData.id, 'rendering');
            
            const imageUrl = this.buildImageUrl(imageData);
            const card = document.querySelector(`[data-image-id="${imageData.id}"]`);
            const img = card.querySelector('.image-card_image');
            const placeholder = card.querySelector('.image-card_placeholder');
            
            // Load image
            await this.loadImageWithTimeout(img, imageUrl, 60000);
            
            // Image loaded successfully
            img.style.display = 'block';
            placeholder.style.display = 'none';
            
            this.updateImageStatus(imageData.id, 'completed');
            this.showCardActions(card, ['download', 'remove']);
            
            // Auto-download if enabled
            if (this.elements.autoDownloadCheckbox.checked) {
                setTimeout(() => this.downloadImage(imageData.id), 1000);
            }
            
        } catch (error) {
            console.error('Error rendering image:', error);
            this.handleImageError(imageData);
        } finally {
            this.activeRenders.delete(imageData.id);
            this.processQueue(); // Process next in queue
        }
    }

    /**
     * Build image URL with parameters
     */
    buildImageUrl(imageData) {
        const params = new URLSearchParams({
            width: imageData.width,
            height: imageData.height,
            seed: imageData.seed,
            model: imageData.model,
            nologo: imageData.nologo
        });

        const encodedPrompt = encodeURIComponent(imageData.prompt);
        return `${this.API_BASE}/prompt/${encodedPrompt}?${params.toString()}`;
    }

    /**
     * Load image with timeout
     */
    loadImageWithTimeout(img, url, timeout = 60000) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                reject(new Error('Image load timeout'));
            }, timeout);

            img.onload = () => {
                clearTimeout(timer);
                resolve();
            };

            img.onerror = () => {
                clearTimeout(timer);
                reject(new Error('Image load failed'));
            };

            img.src = url;
        });
    }

    /**
     * Handle image loading error
     */
    handleImageError(imageData) {
        imageData.retryCount++;
        
        if (imageData.retryCount <= imageData.maxRetries) {
            // Retry with new seed
            imageData.seed = Math.floor(Math.random() * 1000000);
            this.imageQueue.unshift(imageData); // Add to front of queue
            this.updateImageStatus(imageData.id, 'pending');
        } else {
            // Max retries reached
            this.updateImageStatus(imageData.id, 'error');
            const card = document.querySelector(`[data-image-id="${imageData.id}"]`);
            this.showCardActions(card, ['retry', 'remove']);
        }
    }

    /**
     * Create image card in gallery
     */
    createImageCard(imageData) {
        const template = this.elements.imageCardTemplate.content.cloneNode(true);
        const card = template.querySelector('.image-card');
        
        card.dataset.imageId = imageData.id;
        card.dataset.status = imageData.status;
        
        // Set content
        card.querySelector('.image-card_prompt').textContent = imageData.prompt;
        card.querySelector('.seed-value').textContent = imageData.seed;
        card.querySelector('.model-value').textContent = this.formatModelName(imageData.model);
        
        // Bind actions
        this.bindCardActions(card, imageData);
        
        // Add to gallery
        this.elements.imageGallery.appendChild(card);
        this.updateEmptyState();
    }

    /**
     * Bind card action buttons
     */
    bindCardActions(card, imageData) {
        const retryBtn = card.querySelector('.retry-button');
        const downloadBtn = card.querySelector('.download-button');
        const removeBtn = card.querySelector('.remove-button');
        const imageContent = card.querySelector('.image-card_content');
        
        retryBtn.addEventListener('click', () => this.retryImage(imageData.id));
        downloadBtn.addEventListener('click', () => this.downloadImage(imageData.id));
        removeBtn.addEventListener('click', () => this.removeImage(imageData.id));
        
        // Fullscreen on image click
        imageContent.addEventListener('click', () => {
            const img = card.querySelector('.image-card_image');
            if (img.src && img.style.display !== 'none') {
                this.openFullscreen(img.src, imageData.prompt, imageData.id);
            }
        });
    }

    /**
     * Update image status
     */
    updateImageStatus(imageId, status) {
        const card = document.querySelector(`[data-image-id="${imageId}"]`);
        if (!card) return;
        
        card.dataset.status = status;
        card.querySelector('.status-text').textContent = this.formatStatus(status);
    }

    /**
     * Format status text
     */
    formatStatus(status) {
        const statusMap = {
            pending: 'Pending',
            rendering: 'Rendering...',
            completed: 'Completed',
            error: 'Error'
        };
        return statusMap[status] || status;
    }

    /**
     * Show card action buttons
     */
    showCardActions(card, actions) {
        const actionButtons = {
            retry: card.querySelector('.retry-button'),
            download: card.querySelector('.download-button'),
            remove: card.querySelector('.remove-button')
        };
        
        // Hide all first
        Object.values(actionButtons).forEach(btn => {
            if (btn) btn.style.display = 'none';
        });
        
        // Show requested actions
        actions.forEach(action => {
            if (actionButtons[action]) {
                actionButtons[action].style.display = 'flex';
            }
        });
    }

    /**
     * Retry image generation
     */
    retryImage(imageId) {
        const card = document.querySelector(`[data-image-id="${imageId}"]`);
        const prompt = card.querySelector('.image-card_prompt').textContent;
        
        // Remove old card
        this.removeImage(imageId);
        
        // Queue new image
        this.queueImage(prompt);
        this.processQueue();
    }

    /**
     * Download image
     */
    async downloadImage(imageId) {
        const card = document.querySelector(`[data-image-id="${imageId}"]`);
        const img = card.querySelector('.image-card_image');
        const downloadBtn = card.querySelector('.download-button');
        
        if (!img.src) return;
        
        try {
            downloadBtn.style.opacity = '0.5';
            downloadBtn.innerHTML = '<span>‚è≥</span>Downloading...';
            
            const response = await fetch(img.src);
            const blob = await response.blob();
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `pollinations-${imageId}-${Date.now()}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            
            downloadBtn.innerHTML = '<span>‚¨áÔ∏è</span>Download';
            downloadBtn.style.opacity = '1';
            
        } catch (error) {
            console.error('Download failed:', error);
            downloadBtn.innerHTML = '<span>‚ùå</span>Failed';
            setTimeout(() => {
                downloadBtn.innerHTML = '<span>‚¨áÔ∏è</span>Download';
                downloadBtn.style.opacity = '1';
            }, 2000);
        }
    }

    /**
     * Remove image from gallery
     */
    removeImage(imageId) {
        const card = document.querySelector(`[data-image-id="${imageId}"]`);
        if (card) {
            card.remove();
            this.updateEmptyState();
        }
        
        // Remove from active renders if present
        this.activeRenders.delete(imageId);
        
        // Remove from queue if present
        this.imageQueue = this.imageQueue.filter(img => img.id !== imageId);
    }

    /**
     * Update empty state visibility
     */
    updateEmptyState() {
        const hasImages = this.elements.imageGallery.children.length > 0;
        this.elements.emptyState.classList.toggle('is-hidden', hasImages);
    }

    /**
     * Refine prompt to target word count
     */
    async refinePrompt() {
        const currentPrompt = this.elements.mainPromptInput.value.trim();
        if (!currentPrompt) {
            this.showNotification('Please enter a prompt first', 'warning');
            return;
        }

        // Store original prompt
        const originalKey = Date.now().toString();
        this.originalPrompts.set(originalKey, currentPrompt);

        const targetWords = parseInt(this.elements.targetWordsSlider.value);
        const customInstructions = this.elements.refinementInstructions.value.trim();

        await this.processPromptRefinement(currentPrompt, targetWords, customInstructions);
    }

    /**
     * Process prompt refinement with LLM using fallback chain
     */
    async processPromptRefinement(prompt, targetWords, customInstructions) {
        const button = this.elements.refineButton;
        const originalContent = button.innerHTML;
        
        try {
            button.classList.add('is-loading');
            button.innerHTML = '<span>‚è≥</span><span>Refining...</span>';
            
            // Clean the prompt - remove unnecessary newlines for AI processing
            const cleanPrompt = prompt.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim();
            
            const systemPrompt = this.buildRefinementSystemPrompt(targetWords, customInstructions);
            
            // Try models with fallback chain
            const modelFallbackChain = ['openai', 'mistral', 'llamascout'];
            let response = null;
            let lastError = null;

            for (const model of modelFallbackChain) {
                // Check if model is available
                const modelExists = this.availableTextModels.some(m => (m.name || m) === model);
                if (!modelExists) continue;

                try {
                    response = await fetch(this.TEXT_API, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [
                                {
                                    role: 'system',
                                    content: systemPrompt
                                },
                                {
                                    role: 'user',
                                    content: cleanPrompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: Math.max(targetWords * 2, 200)
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const refinedPrompt = data.choices[0].message.content.trim();
                        
                        // Clean newlines from refined prompt
                        const finalPrompt = refinedPrompt.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim();
                        
                        this.elements.mainPromptInput.value = finalPrompt;
                        this.showNotification(`Prompt refined to ~${targetWords} words using ${model}`, 'success');
                        return; // Success, exit the function
                        
                    } else if (response.status === 402) {
                        // Authentication error, try next model
                        lastError = `Model ${model} requires higher tier`;
                        continue;
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                } catch (error) {
                    console.error(`Error with model ${model}:`, error);
                    lastError = error.message;
                    continue; // Try next model
                }
            }
            
            // If we get here, all models failed
            throw new Error(lastError || 'All models failed');
            
        } catch (error) {
            console.error('Error refining prompt:', error);
            this.showNotification(`Failed to refine prompt: ${error.message}`, 'error');
        } finally {
            button.classList.remove('is-loading');
            button.innerHTML = originalContent;
        }
    }

    /**
     * Build system prompt for refinement
     */
    buildRefinementSystemPrompt(targetWords, customInstructions) {
        let systemPrompt = `You are an expert AI image generation prompt optimizer. Transform the user's prompt to be exactly ${targetWords} words long while preserving the core visual concept. CRITICAL: Always keep the main subject as the first words of the prompt - never move it to the middle or end.`;
        
        if (targetWords <= 30) {
            systemPrompt += ` Focus on essential visual elements: main subject first, then style, lighting, and composition. Keep the subject hierarchy from the original prompt. Remove abstract concepts and unnecessary descriptors while maintaining the primary subject at the beginning.`;
        } else if (targetWords <= 100) {
            systemPrompt += ` Start with the main subject, then add specific visual details about lighting, colors, composition, and artistic style. The subject mentioned first in the original prompt should remain first in the refined version. Expand with relevant visual details while maintaining subject priority.`;
        } else {
            systemPrompt += ` Begin with the main subject from the original prompt, then create a rich, detailed description with specific visual elements: lighting (natural, dramatic, soft), composition (rule of thirds, symmetry, depth), artistic style (photorealistic, painterly, cinematic), colors, textures, mood, and technical aspects (camera angles, lens effects). Always preserve the original subject hierarchy and order.`;
        }
        
        if (customInstructions) {
            systemPrompt += ` Additional requirements: ${customInstructions}`;
        }
        
        systemPrompt += ` IMPORTANT: Maintain the exact subject order from the original prompt. If the original starts with "flower can", the refined version must also start with "flower can". Return only the optimized prompt, nothing else. Ensure it's suitable for AI image generation and contains no line breaks.`;
        
        return systemPrompt;
    }

    /**
     * Open fullscreen image view
     */
    openFullscreen(imageSrc, prompt, imageId) {
        // Build array of completed images for navigation
        this.buildFullscreenImageArray();
        
        // Find current image index
        this.currentFullscreenIndex = this.fullscreenImages.findIndex(img => img.id === imageId);
        if (this.currentFullscreenIndex === -1) this.currentFullscreenIndex = 0;
        
        this.elements.fullscreenImage.src = imageSrc;
        this.elements.fullscreenPrompt.textContent = prompt || 'No prompt available';
        this.elements.fullscreenModal.classList.add('is-open');
        document.body.style.overflow = 'hidden';
    }

    /**
     * Navigate between images in fullscreen mode
     */
    navigateFullscreen(direction) {
        if (this.fullscreenImages.length === 0) return;
        
        if (direction === 'next') {
            this.currentFullscreenIndex = (this.currentFullscreenIndex + 1) % this.fullscreenImages.length;
        } else if (direction === 'prev') {
            this.currentFullscreenIndex = (this.currentFullscreenIndex - 1 + this.fullscreenImages.length) % this.fullscreenImages.length;
        }
        
        const currentImage = this.fullscreenImages[this.currentFullscreenIndex];
        if (currentImage) {
            this.elements.fullscreenImage.src = currentImage.src;
            this.elements.fullscreenPrompt.textContent = currentImage.prompt;
        }
    }

    /**
     * Build array of completed images for fullscreen navigation
     */
    buildFullscreenImageArray() {
        this.fullscreenImages = [];
        const completedCards = document.querySelectorAll('.image-card[data-status="completed"]');
        
        completedCards.forEach(card => {
            const img = card.querySelector('.image-card_image');
            const prompt = card.querySelector('.image-card_prompt').textContent;
            const imageId = parseInt(card.dataset.imageId);
            
            if (img.src && img.style.display !== 'none') {
                this.fullscreenImages.push({
                    id: imageId,
                    src: img.src,
                    prompt: prompt
                });
            }
        });
    }

    /**
     * Close fullscreen image view
     */
    closeFullscreen() {
        this.elements.fullscreenModal.classList.remove('is-open');
        document.body.style.overflow = '';
        // Clear image src after animation
        setTimeout(() => {
            this.elements.fullscreenImage.src = '';
            this.elements.fullscreenPrompt.textContent = '';
        }, 300);
    }

    /**
     * Copy prompt to clipboard
     */
    async copyPromptToClipboard() {
        const prompt = this.elements.fullscreenPrompt.textContent;
        const button = this.elements.copyPromptButton;
        const originalContent = button.innerHTML;
        
        try {
            await navigator.clipboard.writeText(prompt);
            button.innerHTML = '<span>‚úÖ</span>Copied!';
            setTimeout(() => {
                button.innerHTML = originalContent;
            }, 2000);
        } catch (error) {
            console.error('Failed to copy prompt:', error);
            button.innerHTML = '<span>‚ùå</span>Failed';
            setTimeout(() => {
                button.innerHTML = originalContent;
            }, 2000);
        }
    }

    /**
     * Toggle settings panel
     */
    toggleSettings() {
        this.elements.settingsPanel.classList.toggle('is-open');
    }

    /**
     * Close settings panel
     */
    closeSettings() {
        this.elements.settingsPanel.classList.remove('is-open');
    }

    /**
     * Show notification
     */
    showNotification(message, type = 'info') {
        console.log(`${type.toUpperCase()}: ${message}`);
        
        // Simple visual feedback in generate button
        if (type === 'success') {
            const button = this.elements.generateButton;
            const originalContent = button.innerHTML;
            button.innerHTML = '<span>‚úÖ</span><span>Success!</span>';
            setTimeout(() => {
                button.innerHTML = originalContent;
            }, 2000);
        }
    }

    /**
     * Update UI state
     */
    updateUI() {
        this.updateEmptyState();
    }

    /**
     * Load settings from localStorage
     */
    loadSettings() {
        const defaultSettings = {
            imageModel: 'flux',
            textModel: 'openai',
            width: 1024,
            height: 1024,
            batchCount: 4,
            seed: -1,
            nologo: true,
            autoDownload: false,
            targetWords: 50,
            refinementInstructions: ''
        };

        try {
            const saved = localStorage.getItem('poliui-settings');
            return saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
        } catch (error) {
            console.error('Error loading settings:', error);
            return defaultSettings;
        }
    }

    /**
     * Save settings to localStorage
     */
    saveSettings() {
        try {
            this.settings = {
                imageModel: this.elements.imageModelSelect.value,
                textModel: this.elements.textModelSelect.value,
                width: parseInt(this.elements.widthInput.value),
                height: parseInt(this.elements.heightInput.value),
                batchCount: parseInt(this.elements.batchCountInput.value),
                seed: parseInt(this.elements.seedInput.value),
                nologo: this.elements.nologoCheckbox.checked,
                autoDownload: this.elements.autoDownloadCheckbox.checked,
                targetWords: parseInt(this.elements.targetWordsSlider.value),
                refinementInstructions: this.elements.refinementInstructions.value
            };

            localStorage.setItem('poliui-settings', JSON.stringify(this.settings));
        } catch (error) {
            console.error('Error saving settings:', error);
        }
    }

    /**
     * Restore settings to UI
     */
    restoreSettings() {
        // Restore basic settings
        this.elements.widthInput.value = this.settings.width;
        this.elements.heightInput.value = this.settings.height;
        this.elements.batchCountInput.value = this.settings.batchCount;
        this.elements.seedInput.value = this.settings.seed;
        this.elements.nologoCheckbox.checked = this.settings.nologo;
        this.elements.autoDownloadCheckbox.checked = this.settings.autoDownload;
        this.elements.targetWordsSlider.value = this.settings.targetWords;
        this.elements.targetWordsValue.textContent = this.settings.targetWords;
        this.elements.refinementInstructions.value = this.settings.refinementInstructions;
        
        // Model selections will be restored after models are loaded
        // This happens automatically via the populate methods
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.polliStudio = new PolliStudio();
});
</script>
</body>
</html>
