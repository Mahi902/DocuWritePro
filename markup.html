<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>PDF Markup</title>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src='https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js'></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --primary: #4a90e2;
            --danger: #e74c3c;
            --bg: #e9ecef;
            --panel: #ffffff;
            --text: #2c3e50;
        }
        body { margin: 0; font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Toolbar */
        #toolbar {
            background: var(--panel); padding: 0.8rem; border-bottom: 1px solid #ddd;
            display: flex; gap: 1rem; align-items: center; overflow-x: auto; white-space: nowrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); z-index: 100; scrollbar-width: thin;
        }
        .tool-group { display: flex; gap: 0.5rem; border-right: 1px solid #eee; padding-right: 1rem; align-items: center; }
        .tool-group:last-child { border-right: none; }
        
        button {
            border: 1px solid #ddd; background: #fff; padding: 0.6rem 0.9rem; border-radius: 6px; 
            cursor: pointer; transition: all 0.2s ease; color: var(--text); font-size: 1rem;
            display: flex; align-items: center; justify-content: center;
        }
        button:hover { background: #f8f9fa; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:active { transform: translateY(0); }
        button.active { background: var(--primary); color: white; border-color: var(--primary); }
        button.danger { color: var(--danger); border-color: var(--danger); }
        button.danger:hover { background: var(--danger); color: white; }
        
        input[type="color"] { width: 36px; height: 36px; padding: 0; border: 2px solid #ddd; border-radius: 4px; cursor: pointer; overflow: hidden; }
        input[type="range"] { width: 100px; accent-color: var(--primary); }
        select { padding: 0.6rem; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; }

        /* Main Area */
        #main-container { flex: 1; overflow: auto; padding: 2rem; text-align: center; position: relative; touch-action: pan-x pan-y; }
        
        /* Page Wrappers */
        .page-container {
            position: relative; margin: 0 auto 2rem auto; box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            display: inline-block; background: white; transition: transform 0.2s ease;
        }
        
        /* Canvas Layers */
        .pdf-canvas { display: block; pointer-events: none; } /* PDF is just an image background */
        .fabric-canvas-wrapper { position: absolute; top: 0; left: 0; z-index: 10; }
        
        /* View Mode: Disables fabric interaction to allow native scroll/zoom */
        body.view-mode .fabric-canvas-wrapper { pointer-events: none; opacity: 0.9; }
        body.view-mode .page-container { cursor: grab; }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95);
            display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 2000;
        }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Helpers */
        .hidden { display: none; }
        #filename-input { border: none; font-weight: 700; font-size: 1.1rem; width: 180px; text-align: left; background: transparent; color: var(--text); }
        #filename-input:focus { outline: 2px solid var(--primary); background: white; }
    </style>
</head>
<body class="">

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text" style="margin-top:15px; font-weight:600; font-size:1.2rem; color: #555;">Processing...</div>
    </div>

    <!-- Toolbar -->
    <div id="toolbar">
        <!-- File Operations -->
        <div class="tool-group">
            <input type="file" id="file-upload" accept="application/pdf" class="hidden">
            <button onclick="document.getElementById('file-upload').click()" title="Open PDF"><i class="fas fa-folder-open"></i></button>
            <input type="text" id="filename-input" value="document.pdf">
            <button onclick="exportPDF()" style="background:#2ecc71; color:white; border:none;" title="Save/Export"><i class="fas fa-save"></i></button>
        </div>

        <!-- Navigation / Mode -->
        <div class="tool-group">
            <button onclick="setTool('view')" id="btn-view" title="View/Pan Mode (Turn off Cursor)"><i class="fas fa-hand-paper"></i></button>
            <button onclick="setTool('select')" id="btn-select" class="active" title="Select/Edit Mode"><i class="fas fa-mouse-pointer"></i></button>
            <button onclick="undo()" title="Undo"><i class="fas fa-undo"></i></button>
            <button onclick="redo()" title="Redo"><i class="fas fa-redo"></i></button>
            <button onclick="deleteSelected()" class="danger" title="Delete Selected Item"><i class="fas fa-trash-alt"></i></button>
        </div>

        <!-- Drawing -->
        <div class="tool-group">
            <button onclick="setTool('marker')" id="btn-marker" title="Marker"><i class="fas fa-pen"></i></button>
            <button onclick="setTool('highlighter_manual')" id="btn-highlighter_manual" title="Manual Highlighter"><i class="fas fa-highlighter"></i></button>
            <button onclick="setTool('eraser')" id="btn-eraser" title="Eraser"><i class="fas fa-eraser"></i></button>
            <input type="color" id="draw-color" value="#ffd700" title="Choose Color" onchange="updateColor()">
            <input type="range" id="draw-width" min="1" max="50" value="10" title="Brush Size" onchange="updateBrush()">
        </div>

        <!-- Shapes, Text & Image -->
        <div class="tool-group">
            <button onclick="addShape('rect')" title="Rectangle"><i class="far fa-square"></i></button>
            <button onclick="addShape('circle')" title="Circle"><i class="far fa-circle"></i></button>
            <button onclick="addShape('arrow')" title="Arrow"><i class="fas fa-long-arrow-alt-right"></i></button>
            <button onclick="addText()" title="Add Text"><i class="fas fa-font"></i></button>
            <button onclick="toggleTextStyle('bold')" title="Bold"><i class="fas fa-bold"></i></button>
            <button onclick="importFont()" title="Google Font"><i class="fab fa-google"></i></button>
            
            <!-- Image Upload Input & Button -->
            <input type="file" id="img-upload" accept="image/*" class="hidden" onchange="handleImageUpload(this)">
            <button onclick="document.getElementById('img-upload').click()" title="Add Image"><i class="fas fa-image"></i></button>
        </div>

        <!-- Auto OCR -->
        <div class="tool-group">
            <select id="ocr-lang">
                <option value="eng">English</option>
                <option value="ben">Bengali (Bangla)</option>
                <option value="spa">Spanish</option>
                <option value="fra">French</option>
            </select>
            <button onclick="runAutoHighlight()" title="Auto-Highlight Text"><i class="fas fa-magic"></i> Auto</button>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="main-container">
        <div style="margin-top: 100px; color: #888;">
            <h2><i class="fas fa-file-pdf" style="font-size: 3rem; margin-bottom: 20px;"></i><br>No PDF Loaded</h2>
            <p>Click the folder icon to open a PDF.</p>
        </div>
    </div>

<script>
    // --- Config & State ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let pdfDoc = null;
    let fabricCanvases = []; 
    let currentTool = 'select';
    let history = []; 
    let historyStep = -1;
    let originalPdfBytes = null;
    let scale = 1.5; // Base render scale

    // --- Initialization ---
    document.getElementById('file-upload').addEventListener('change', handleFileUpload);

    async function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        document.getElementById('filename-input').value = file.name;
        showLoader(true, "Rendering PDF pages...");
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            
            // IMPORTANT FIX: Clone the buffer for later use. 
            // PDF.js worker transfers the buffer, making it detached and unusable for export otherwise.
            originalPdfBytes = arrayBuffer.slice(0); 
            
            const loadingTask = pdfjsLib.getDocument(arrayBuffer);
            pdfDoc = await loadingTask.promise;
            
            document.getElementById('main-container').innerHTML = '';
            fabricCanvases = [];

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                await renderPage(i);
            }
            // Switch to view mode initially for easier scrolling
            setTool('view');
        } catch (err) {
            console.error(err);
            alert("Error loading PDF: " + err.message);
        } finally {
            showLoader(false);
        }
    }

    async function renderPage(pageNum) {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: scale });

        // Container
        const wrapper = document.createElement('div');
        wrapper.className = 'page-container';
        wrapper.style.width = `${viewport.width}px`;
        wrapper.style.height = `${viewport.height}px`;
        wrapper.dataset.pageIndex = pageNum - 1;

        // PDF Canvas (Bottom Layer - Image)
        const pdfCanvas = document.createElement('canvas');
        pdfCanvas.className = 'pdf-canvas';
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        const ctx = pdfCanvas.getContext('2d');
        
        await page.render({ canvasContext: ctx, viewport: viewport }).promise;

        // Fabric Canvas (Top Layer - Interactive)
        const canvasEl = document.createElement('canvas');
        canvasEl.width = viewport.width;
        canvasEl.height = viewport.height;
        
        wrapper.appendChild(pdfCanvas);
        
        const fabricWrapper = document.createElement('div');
        fabricWrapper.className = 'fabric-canvas-wrapper';
        fabricWrapper.appendChild(canvasEl);
        wrapper.appendChild(fabricWrapper);
        
        document.getElementById('main-container').appendChild(wrapper);

        // Initialize Fabric
        const fCanvas = new fabric.Canvas(canvasEl, {
            isDrawingMode: false,
            selection: true,
            preserveObjectStacking: true
        });

        // Event Listeners
        fCanvas.on('object:added', () => saveHistory(pageNum - 1));
        fCanvas.on('object:modified', () => saveHistory(pageNum - 1));
        fCanvas.on('path:created', () => saveHistory(pageNum - 1));
        
        // Handle object selection to update UI
        fCanvas.on('selection:created', (e) => onObjectSelected(e));
        fCanvas.on('selection:updated', (e) => onObjectSelected(e));

        fabricCanvases.push(fCanvas);
    }

    function onObjectSelected(e) {
        // If we select a shape or text, update the color picker to match
        const obj = e.selected[0];
        if (obj) {
            const color = obj.fill || obj.stroke;
            if(color && typeof color === 'string' && color.startsWith('#')) {
                // document.getElementById('draw-color').value = color; // Optional: Sync picker to object
            }
        }
    }

    // --- Tools Logic ---

    function setTool(tool) {
        currentTool = tool;
        
        // UI Updates
        document.querySelectorAll('#toolbar button').forEach(b => b.classList.remove('active'));
        if(document.getElementById(`btn-${tool}`)) document.getElementById(`btn-${tool}`).classList.add('active');

        // Body class for View Mode (native scrolling)
        if (tool === 'view') {
            document.body.classList.add('view-mode');
        } else {
            document.body.classList.remove('view-mode');
        }

        // Configure Canvases
        fabricCanvases.forEach(canvas => {
            canvas.isDrawingMode = false;
            canvas.selection = (tool === 'select');
            canvas.defaultCursor = 'default';

            if (tool === 'view') {
                // Handled by CSS pointer-events: none
                canvas.selection = false;
            } 
            else if (tool === 'marker' || tool === 'highlighter_manual') {
                canvas.isDrawingMode = true;
                const brush = new fabric.PencilBrush(canvas);
                const color = document.getElementById('draw-color').value;
                const width = parseInt(document.getElementById('draw-width').value);
                
                if (tool === 'highlighter_manual') {
                    brush.color = hexToRgba(color, 0.4);
                    brush.width = width * 3;
                    canvas.freeDrawingBrush = brush;
                } else {
                    brush.color = color;
                    brush.width = width;
                    canvas.freeDrawingBrush = brush;
                }
            } 
            else if (tool === 'eraser') {
                 canvas.defaultCursor = 'not-allowed';
                 canvas.selection = false;
            }
        });
    }

    function updateColor() {
        const color = document.getElementById('draw-color').value;
        
        // 1. Update Brush if drawing
        if(currentTool === 'marker' || currentTool === 'highlighter_manual') {
            setTool(currentTool); 
        }

        // 2. Update Selected Object (Live Edit)
        const canvas = getActiveCanvas();
        if(canvas) {
            const activeObj = canvas.getActiveObject();
            if(activeObj) {
                // Handle different object types
                if (activeObj.type === 'i-text' || activeObj.type === 'rect' || activeObj.type === 'circle' || activeObj.type === 'path') {
                    // For shapes/text
                    if(activeObj.fill && activeObj.fill !== 'transparent') activeObj.set('fill', color);
                    if(activeObj.stroke) activeObj.set('stroke', color);
                    
                    // Specific handling for OCR Highlights which use opacity
                    if(activeObj.data && activeObj.data.isOcrZone) {
                        activeObj.set('fill', color);
                        activeObj.set('opacity', 0.4); 
                    }
                    
                    canvas.renderAll();
                    saveHistory(fabricCanvases.indexOf(canvas));
                }
            }
        }
    }

    function updateBrush() {
        if(currentTool === 'marker' || currentTool === 'highlighter_manual') setTool(currentTool);
    }

    // Universal Delete
    function deleteSelected() {
        const canvas = getActiveCanvas();
        if (!canvas) return;
        
        const activeObj = canvas.getActiveObject();
        if (activeObj) {
            canvas.remove(activeObj);
            saveHistory(fabricCanvases.indexOf(canvas));
        } else {
            // Fallback: check all canvases (in case user clicked a button and focus shifted)
            fabricCanvases.forEach((c, idx) => {
                if(c.getActiveObject()) {
                    c.remove(c.getActiveObject());
                    saveHistory(idx);
                }
            });
        }
    }

    // Global Eraser Click
    document.addEventListener('mousedown', (e) => {
        if (currentTool !== 'eraser') return;
        const wrapper = e.target.closest('.upper-canvas');
        if (!wrapper) return;
        
        const canvasIndex = fabricCanvases.findIndex(fc => fc.upperCanvasEl === wrapper);
        if (canvasIndex === -1) return;
        
        const canvas = fabricCanvases[canvasIndex];
        const pointer = canvas.getPointer(e);
        const objects = canvas.getObjects();
        
        // Find object under mouse with pixel precision
        for (let i = objects.length - 1; i >= 0; i--) {
            if (objects[i].containsPoint(pointer)) {
                canvas.remove(objects[i]);
                saveHistory(canvasIndex);
                break;
            }
        }
    });

    // --- Shapes, Text & Images ---

    function getActiveCanvas() {
        // Return the canvas whose wrapper is currently most visible in viewport
        const wrappers = document.querySelectorAll('.page-container');
        let bestIndex = 0;
        let maxVisible = 0;
        
        wrappers.forEach((w, i) => {
            const rect = w.getBoundingClientRect();
            // Calculate visible height overlap
            const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
            if (visibleHeight > maxVisible) {
                maxVisible = visibleHeight;
                bestIndex = i;
            }
        });
        
        return fabricCanvases[bestIndex];
    }

    function addShape(type) {
        const canvas = getActiveCanvas();
        if(!canvas) return;
        
        // Force select tool so we can manipulate the shape immediately
        setTool('select');
        
        const color = document.getElementById('draw-color').value;
        // Place in center of viewport, not just center of page
        const vpt = canvas.vptCoords || canvas.getCenter();
        const center = { left: canvas.width / 2, top: canvas.height / 2 }; 
        
        let obj;
        const commonProps = { 
            left: center.left, top: center.top, 
            originX: 'center', originY: 'center',
            stroke: color, strokeWidth: 3, fill: 'transparent',
            cornerColor: 'blue', cornerSize: 10, transparentCorners: false
        };

        if (type === 'rect') {
            obj = new fabric.Rect({ ...commonProps, width: 100, height: 100 });
        } else if (type === 'circle') {
            obj = new fabric.Circle({ ...commonProps, radius: 50 });
        } else if (type === 'arrow') {
            const path = `M 0 0 L 100 0 M 90 -10 L 100 0 L 90 10`;
            obj = new fabric.Path(path, { ...commonProps, fill: 'transparent' });
        }

        canvas.add(obj);
        canvas.setActiveObject(obj);
    }

    function addText() {
        const canvas = getActiveCanvas();
        if(!canvas) return;
        setTool('select');
        
        const color = document.getElementById('draw-color').value;
        const text = new fabric.IText('Type here...', {
            left: canvas.width / 2,
            top: canvas.height / 2,
            fontFamily: 'Arial',
            fill: color,
            fontSize: 24,
            originX: 'center', originY: 'center'
        });
        
        canvas.add(text);
        canvas.setActiveObject(text);
    }

    function toggleTextStyle(style) {
        const canvas = getActiveCanvas();
        const obj = canvas.getActiveObject();
        if (!obj || obj.type !== 'i-text') return;

        if (style === 'bold') {
            obj.set('fontWeight', obj.fontWeight === 'bold' ? 'normal' : 'bold');
        }
        canvas.renderAll();
        saveHistory(fabricCanvases.indexOf(canvas));
    }

    function importFont() {
        const url = prompt("Paste Google Fonts URL (CSS link):", "https://fonts.googleapis.com/css?family=Lobster");
        if (!url) return;
        
        try {
            // Extract font name assuming format "family=Font+Name"
            const familyMatch = url.match(/family=([^&:]+)/);
            if (!familyMatch) throw new Error("Invalid Google Fonts URL");
            
            const fontName = familyMatch[1].replace(/\+/g, ' ');
            
            // Append link to head
            const link = document.createElement('link');
            link.href = url;
            link.rel = 'stylesheet';
            document.head.appendChild(link);
            
            // Apply to selected text
            const canvas = getActiveCanvas();
            const obj = canvas.getActiveObject();
            if (obj && obj.type === 'i-text') {
                obj.set('fontFamily', fontName);
                canvas.renderAll();
            }
            alert(`Font "${fontName}" loaded.`);
        } catch(e) {
            alert("Could not load font. Make sure it's a valid Google Fonts CSS URL.");
        }
    }
    
    // --- Image Upload Logic ---
    function handleImageUpload(input) {
        const file = input.files[0];
        if (!file) return;

        const canvas = getActiveCanvas();
        if (!canvas) {
            alert("Please open a PDF document first.");
            input.value = ''; // Reset
            return;
        }

        const reader = new FileReader();
        reader.onload = function(f) {
            const data = f.target.result;
            fabric.Image.fromURL(data, function(img) {
                // Scale image down if it's too large for the page
                const maxDim = 300;
                if (img.width > maxDim || img.height > maxDim) {
                    img.scaleToWidth(maxDim);
                }

                img.set({
                    left: canvas.width / 2,
                    top: canvas.height / 2,
                    originX: 'center',
                    originY: 'center',
                    cornerColor: 'blue',
                    cornerSize: 10,
                    transparentCorners: false
                });

                canvas.add(img);
                canvas.setActiveObject(img);
                
                // Automatically switch to 'select' tool to allow immediate manipulation
                setTool('select');
                
                // Clear input so same file can be selected again if needed
                input.value = '';
                
                saveHistory(fabricCanvases.indexOf(canvas));
            });
        };
        reader.readAsDataURL(file);
    }


    // --- Auto Highlighter (OCR with Bangla) ---

    async function runAutoHighlight() {
        const canvas = getActiveCanvas();
        if(!canvas) { alert("Please load a PDF first."); return; }
        
        const pageIndex = fabricCanvases.indexOf(canvas);
        const wrapper = document.querySelectorAll('.page-container')[pageIndex];
        const pdfCanvas = wrapper.querySelector('.pdf-canvas');
        const lang = document.getElementById('ocr-lang').value;
        
        showLoader(true, `Scanning page ${pageIndex + 1} (${lang})...`);

        try {
            // Get image data
            const imgUrl = pdfCanvas.toDataURL('image/png');
            
            // Run Tesseract
            const { data: { lines } } = await Tesseract.recognize(imgUrl, lang, {
                logger: m => {
                    if(m.status === 'recognizing text') {
                        document.getElementById('loader-text').innerText = `Recognizing: ${Math.round(m.progress * 100)}%`;
                    }
                }
            });
            
            showLoader(false);
            
            if (lines.length === 0) {
                alert("No text detected.");
                return;
            }

            // Create interactive zones
            lines.forEach(line => {
                const { bbox } = line;
                const rect = new fabric.Rect({
                    left: bbox.x0,
                    top: bbox.y0,
                    width: bbox.x1 - bbox.x0,
                    height: bbox.y1 - bbox.y0,
                    fill: document.getElementById('draw-color').value, // Use current color
                    opacity: 0, // Invisible initially
                    hoverCursor: 'pointer',
                    selectable: false, // Don't allow dragging OCR zones
                    data: { isOcrZone: true }
                });

                // Interaction Logic
                rect.on('mouseover', () => { 
                    if (!rect.permanent) { rect.set('opacity', 0.2); canvas.renderAll(); }
                });
                
                rect.on('mouseout', () => { 
                    if (!rect.permanent) { rect.set('opacity', 0); canvas.renderAll(); }
                });
                
                rect.on('mousedown', () => {
                    // Toggle permanence
                    rect.permanent = !rect.permanent;
                    rect.set('opacity', rect.permanent ? 0.4 : 0.2);
                    rect.set('fill', document.getElementById('draw-color').value);
                    
                    // Allow selection when permanent so it can be deleted
                    rect.selectable = rect.permanent; 
                    
                    canvas.renderAll();
                    saveHistory(pageIndex);
                });

                canvas.add(rect);
            });
            
            canvas.renderAll();
            // Switch to Select tool so user can click the highlights
            setTool('select');
            alert(`Found ${lines.length} text lines. Hover and click to highlight.`);

        } catch (err) {
            console.error(err);
            showLoader(false);
            alert("OCR Failed. Ensure this is running on a local server.");
        }
    }

    // --- History ---

    function saveHistory(pageIndex) {
        if(historyStep < history.length - 1) {
            history = history.slice(0, historyStep + 1);
        }
        const state = JSON.stringify(fabricCanvases[pageIndex].toJSON(['data'])); // Include custom 'data' property
        history.push({ pageIndex, state });
        historyStep++;
    }

    function undo() {
        if (historyStep > 0) {
            historyStep--;
            const { pageIndex, state } = history[historyStep];
            fabricCanvases[pageIndex].loadFromJSON(JSON.parse(state), () => fabricCanvases[pageIndex].renderAll());
        }
    }

    function redo() {
        if (historyStep < history.length - 1) {
            historyStep++;
            const { pageIndex, state } = history[historyStep];
            fabricCanvases[pageIndex].loadFromJSON(JSON.parse(state), () => fabricCanvases[pageIndex].renderAll());
        }
    }

    // --- Export ---

    async function exportPDF() {
        if (!originalPdfBytes) return;
        showLoader(true, "Finalizing PDF...");

        try {
            const { PDFDocument } = PDFLib;
            const pdfDoc = await PDFDocument.load(originalPdfBytes);
            const pages = pdfDoc.getPages();

            for (let i = 0; i < pages.length; i++) {
                const fabricCanvas = fabricCanvases[i];
                if (fabricCanvas.getObjects().length === 0) continue;

                // 1. Hide non-permanent OCR zones before screenshot
                const objects = fabricCanvas.getObjects();
                objects.forEach(o => {
                    if (o.data && o.data.isOcrZone && !o.permanent) o.visible = false;
                });
                
                // 2. Generate PNG of the canvas
                const dataUrl = fabricCanvas.toDataURL({ format: 'png', multiplier: 2 });
                
                // 3. Restore visibility (optional, if user keeps editing)
                objects.forEach(o => {
                     if (o.data && o.data.isOcrZone && !o.permanent) o.visible = true;
                });

                // 4. Embed
                const pngImage = await pdfDoc.embedPng(dataUrl);
                const page = pages[i];
                const { width, height } = page.getSize();

                page.drawImage(pngImage, { x: 0, y: 0, width: width, height: height });
            }

            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = (document.getElementById('filename-input').value || 'annotated') + '.pdf';
            link.click();

        } catch (e) {
            console.error(e);
            alert("Export failed: " + e.message);
        } finally {
            showLoader(false);
        }
    }

    // --- Utils ---
    function showLoader(show, text) {
        const l = document.getElementById('loader');
        l.style.display = show ? 'flex' : 'none';
        if(text) document.getElementById('loader-text').innerText = text;
    }
    
    function hexToRgba(hex, alpha) {
        var r = parseInt(hex.slice(1, 3), 16),
            g = parseInt(hex.slice(3, 5), 16),
            b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }
</script>
</body>
</html>
