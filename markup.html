<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
    <title>PDF Markup & Reconstructor</title>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src='https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js'></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --primary: #4a90e2;
            --danger: #e74c3c;
            --success: #2ecc71;
            --warning: #f1c40f;
            --bg: #e9ecef;
            --panel: #ffffff;
            --text: #2c3e50;
        }
        body { margin: 0; font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* Toolbar */
        #toolbar {
            background: var(--panel); padding: 0.8rem; border-bottom: 1px solid #ddd;
            display: flex; gap: 1rem; align-items: center; overflow-x: auto; white-space: nowrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); z-index: 100; scrollbar-width: thin;
        }
        .tool-group { display: flex; gap: 0.5rem; border-right: 1px solid #eee; padding-right: 1rem; align-items: center; }
        .tool-group:last-child { border-right: none; }
        
        button {
            border: 1px solid #ddd; background: #fff; padding: 0.6rem 0.9rem; border-radius: 6px; 
            cursor: pointer; transition: all 0.2s ease; color: var(--text); font-size: 1rem;
            display: flex; align-items: center; justify-content: center; position: relative;
        }
        button:hover { background: #f8f9fa; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button:active { transform: translateY(0); }
        button.active { background: var(--primary); color: white; border-color: var(--primary); }
        
        button.danger { color: var(--danger); border-color: var(--danger); }
        button.danger:hover { background: var(--danger); color: white; }
        
        button.reconstruct-active { background: var(--warning); color: #333; border-color: #e6b333; animation: pulse 2s infinite; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(241, 196, 15, 0); } 100% { box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); } }
        
        input[type="color"] { width: 36px; height: 36px; padding: 0; border: 2px solid #ddd; border-radius: 4px; cursor: pointer; overflow: hidden; vertical-align: middle; }
        input[type="number"] { width: 60px; padding: 0.5rem; border: 1px solid #ddd; border-radius: 6px; }
        input[type="range"] { width: 100px; accent-color: var(--primary); }
        select { padding: 0.6rem; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; }

        /* Main Area */
        #main-container { flex: 1; overflow: auto; padding: 2rem; text-align: center; position: relative; touch-action: pan-x pan-y; }
        
        /* Page Wrappers */
        .page-container {
            position: relative; margin: 0 auto 2rem auto; box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            display: inline-block; background: white; transition: transform 0.2s ease;
        }
        
        /* Canvas Layers */
        .pdf-canvas { display: block; pointer-events: none; } /* PDF is just an image background */
        .fabric-canvas-wrapper { position: absolute; top: 0; left: 0; z-index: 10; }
        
        /* View Mode */
        body.view-mode .fabric-canvas-wrapper { pointer-events: none; opacity: 0.9; }
        body.view-mode .page-container { cursor: grab; }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95);
            display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 2000;
        }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Instructions Overlay */
        #msg-overlay {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px;
            z-index: 1000; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            font-weight: 500; font-size: 1rem;
        }
        #msg-overlay.visible { opacity: 1; }

        /* Helpers */
        .hidden { display: none; }
        #filename-input { border: none; font-weight: 700; font-size: 1.1rem; width: 180px; text-align: left; background: transparent; color: var(--text); }
        #filename-input:focus { outline: 2px solid var(--primary); background: white; }
    </style>
</head>
<body class="">

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text" style="margin-top:15px; font-weight:600; font-size:1.2rem; color: #555;">Processing...</div>
    </div>

    <!-- Message Overlay -->
    <div id="msg-overlay"></div>

    <!-- Toolbar -->
    <div id="toolbar">
        <!-- File Operations -->
        <div class="tool-group">
            <input type="file" id="file-upload" accept="application/pdf" class="hidden">
            <button onclick="document.getElementById('file-upload').click()" title="Open PDF"><i class="fas fa-folder-open"></i></button>
            <input type="text" id="filename-input" value="document.pdf">
            <button onclick="exportPDF()" style="background:#2ecc71; color:white; border:none;" title="Save/Export"><i class="fas fa-save"></i></button>
        </div>

        <!-- Navigation / Mode -->
        <div class="tool-group">
            <button onclick="setTool('view')" id="btn-view" title="View/Pan Mode"><i class="fas fa-hand-paper"></i></button>
            <button onclick="setTool('select')" id="btn-select" class="active" title="Select/Edit Mode"><i class="fas fa-mouse-pointer"></i></button>
            <button onclick="undo()" title="Undo"><i class="fas fa-undo"></i></button>
            <button onclick="redo()" title="Redo"><i class="fas fa-redo"></i></button>
            <button onclick="deleteSelected()" class="danger" title="Delete Selected"><i class="fas fa-trash-alt"></i></button>
        </div>

        <!-- Text Styling -->
        <div class="tool-group">
             <div style="display:flex; flex-direction:column; gap:2px; align-items:center;">
                <label style="font-size:0.7rem; color:#666;">Size</label>
                <input type="number" id="text-size" value="20" min="1" max="200" title="Font Size" onchange="updateFontSize()">
            </div>
            <div style="display:flex; flex-direction:column; gap:2px; align-items:center;">
                <label style="font-size:0.7rem; color:#666;">Color</label>
                <input type="color" id="draw-color" value="#2c3e50" title="Text/Brush Color" onchange="updateColor()">
            </div>
             <button onclick="toggleTextStyle('bold')" title="Bold"><i class="fas fa-bold"></i></button>
        </div>

        <!-- Drawing -->
        <div class="tool-group">
            <button onclick="setTool('marker')" id="btn-marker" title="Marker"><i class="fas fa-pen"></i></button>
            <button onclick="setTool('highlighter_manual')" id="btn-highlighter_manual" title="Highlighter"><i class="fas fa-highlighter"></i></button>
            <button onclick="setTool('eraser')" id="btn-eraser" title="Eraser"><i class="fas fa-eraser"></i></button>
            <input type="range" id="draw-width" min="1" max="50" value="5" title="Brush Size" onchange="updateBrush()">
        </div>

        <!-- Objects -->
        <div class="tool-group">
            <button onclick="addShape('rect')" title="Rectangle"><i class="far fa-square"></i></button>
            <button onclick="addShape('circle')" title="Circle"><i class="far fa-circle"></i></button>
            <button onclick="addText()" title="Add Text"><i class="fas fa-font"></i></button>
            
            <input type="file" id="img-upload" accept="image/*" class="hidden" onchange="handleImageUpload(this)">
            <button onclick="document.getElementById('img-upload').click()" title="Add Image"><i class="fas fa-image"></i></button>
        </div>

        <!-- Advanced Tools -->
        <div class="tool-group" style="flex:1; justify-content: flex-end;">
            <select id="ocr-lang" title="OCR Language">
                <option value="eng">English</option>
                <option value="ben">Bengali</option>
                <option value="spa">Spanish</option>
                <option value="fra">French</option>
                <option value="deu">German</option>
            </select>
            <!-- Original Auto Highlight -->
            <button onclick="runAutoHighlight()" title="Highlight Text"><i class="fas fa-highlighter"></i> Auto</button>
            
            <!-- NEW Reconstruct Tool -->
            <button id="btn-reconstruct" onclick="toggleReconstruct()" title="Reconstruct Page from Scan">
                <i class="fas fa-magic"></i>&nbsp;Reconstruct
            </button>
        </div>
    </div>

    <!-- Canvas Container -->
    <div id="main-container">
        <div style="margin-top: 100px; color: #888;">
            <h2><i class="fas fa-file-pdf" style="font-size: 3rem; margin-bottom: 20px;"></i><br>No PDF Loaded</h2>
            <p>Click the folder icon to open a PDF.</p>
        </div>
    </div>

<script>
    // --- Config & State ---
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    let pdfDoc = null;
    let fabricCanvases = []; 
    let currentTool = 'select';
    let history = []; 
    let historyStep = -1;
    let originalPdfBytes = null;
    let scale = 1.5; 

    // Reconstruct State
    let isReconstructMode = false;
    let reconstructSafeRects = [];
    let reconstructMouseStart = null;
    let reconstructActiveRect = null;

    // --- Initialization ---
    document.getElementById('file-upload').addEventListener('change', handleFileUpload);

    async function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        document.getElementById('filename-input').value = file.name;
        showLoader(true, "Rendering PDF pages...");
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            originalPdfBytes = arrayBuffer.slice(0); 
            
            const loadingTask = pdfjsLib.getDocument(arrayBuffer);
            pdfDoc = await loadingTask.promise;
            
            document.getElementById('main-container').innerHTML = '';
            fabricCanvases = [];
            history = []; historyStep = -1;

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                await renderPage(i);
            }
            setTool('view');
        } catch (err) {
            console.error(err);
            alert("Error loading PDF: " + err.message);
        } finally {
            showLoader(false);
        }
    }

    async function renderPage(pageNum) {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: scale });

        const wrapper = document.createElement('div');
        wrapper.className = 'page-container';
        wrapper.style.width = `${viewport.width}px`;
        wrapper.style.height = `${viewport.height}px`;
        wrapper.dataset.pageIndex = pageNum - 1;

        // Background PDF Image (Bottom Layer)
        const pdfCanvas = document.createElement('canvas');
        pdfCanvas.className = 'pdf-canvas';
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        const ctx = pdfCanvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport: viewport }).promise;

        const fabricWrapper = document.createElement('div');
        fabricWrapper.className = 'fabric-canvas-wrapper';
        
        const canvasEl = document.createElement('canvas');
        canvasEl.width = viewport.width;
        canvasEl.height = viewport.height;
        
        fabricWrapper.appendChild(canvasEl);
        wrapper.appendChild(pdfCanvas); // PDF Image
        wrapper.appendChild(fabricWrapper); // Fabric
        
        document.getElementById('main-container').appendChild(wrapper);

        const fCanvas = new fabric.Canvas(canvasEl, {
            selection: true,
            preserveObjectStacking: true
        });

        // Event hooks
        fCanvas.on('object:added', () => { if(!isReconstructMode) saveHistory(pageNum - 1); });
        fCanvas.on('object:modified', () => { if(!isReconstructMode) saveHistory(pageNum - 1); });
        fCanvas.on('selection:created', onObjectSelected);
        fCanvas.on('selection:updated', onObjectSelected);
        
        // Reconstruct Mouse Events
        fCanvas.on('mouse:down', (opt) => handleReconstructMouseDown(fCanvas, opt));
        fCanvas.on('mouse:move', (opt) => handleReconstructMouseMove(fCanvas, opt));
        fCanvas.on('mouse:up', (opt) => handleReconstructMouseUp(fCanvas, opt));

        fabricCanvases.push(fCanvas);
    }

    function onObjectSelected(e) {
        const obj = e.selected[0];
        if (obj) {
            // Update Color Picker
            const color = obj.fill || obj.stroke;
            if(color && typeof color === 'string' && color.startsWith('#')) {
                document.getElementById('draw-color').value = color;
            }
            // Update Font Size Input
            if (obj.type === 'i-text' || obj.type === 'textbox') {
                if (obj.fontSize) document.getElementById('text-size').value = obj.fontSize;
            }
        }
    }

    // --- Core Tool Logic ---

    function setTool(tool) {
        // Prevent changing tool if mid-reconstruction unless cancelling
        if (isReconstructMode && tool !== 'reconstruct') {
             if (!confirm("Stop Reconstruction?")) return;
             isReconstructMode = false;
             resetReconstructUI();
        }

        currentTool = tool;
        document.querySelectorAll('#toolbar button').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById(`btn-${tool}`);
        if(btn) btn.classList.add('active');

        document.body.classList.toggle('view-mode', tool === 'view');

        fabricCanvases.forEach(canvas => {
            canvas.isDrawingMode = false;
            canvas.selection = (tool === 'select');
            canvas.defaultCursor = 'default';

            if (tool === 'marker' || tool === 'highlighter_manual') {
                canvas.isDrawingMode = true;
                const brush = new fabric.PencilBrush(canvas);
                const color = document.getElementById('draw-color').value;
                const width = parseInt(document.getElementById('draw-width').value);
                
                brush.color = tool === 'highlighter_manual' ? hexToRgba(color, 0.4) : color;
                brush.width = tool === 'highlighter_manual' ? width * 3 : width;
                canvas.freeDrawingBrush = brush;
            } else if (tool === 'eraser') {
                 canvas.defaultCursor = 'not-allowed';
                 canvas.selection = false;
            } else if (tool === 'reconstruct') {
                 canvas.selection = false;
                 canvas.defaultCursor = 'crosshair';
            }
        });
    }

    // --- Text Styling (New) ---

    function updateFontSize() {
        const size = parseInt(document.getElementById('text-size').value);
        const canvas = getActiveCanvas();
        if(!canvas) return;
        const obj = canvas.getActiveObject();
        if (obj && (obj.type === 'i-text' || obj.type === 'textbox')) {
            obj.set('fontSize', size);
            canvas.renderAll();
            saveHistory(fabricCanvases.indexOf(canvas));
        }
    }

    function updateColor() {
        const color = document.getElementById('draw-color').value;
        
        // Update Brush
        if(currentTool === 'marker' || currentTool === 'highlighter_manual') {
            setTool(currentTool); 
        }

        // Update Objects (Text & Shape)
        const canvas = getActiveCanvas();
        if(canvas) {
            const activeObj = canvas.getActiveObject();
            if(activeObj) {
                // If text, change fill (color)
                if (activeObj.type === 'i-text' || activeObj.type === 'textbox') {
                    activeObj.set('fill', color);
                } 
                // If shape, change stroke or fill depending on logic (here assume fill for simple shapes)
                else if (['rect','circle','path'].includes(activeObj.type)) {
                     // If it's a solid shape, change fill
                     if(activeObj.fill !== 'transparent') activeObj.set('fill', color);
                     // Always change stroke if present
                     if(activeObj.stroke) activeObj.set('stroke', color);
                }
                
                canvas.renderAll();
                saveHistory(fabricCanvases.indexOf(canvas));
            }
        }
    }

    function toggleTextStyle(style) {
        const canvas = getActiveCanvas();
        if(!canvas) return;
        const obj = canvas.getActiveObject();
        if (!obj || (obj.type !== 'i-text' && obj.type !== 'textbox')) return;

        if (style === 'bold') {
            obj.set('fontWeight', obj.fontWeight === 'bold' ? 'normal' : 'bold');
        }
        canvas.renderAll();
        saveHistory(fabricCanvases.indexOf(canvas));
    }

    // --- Reconstruct Tool Logic ---

    function toggleReconstruct() {
        const btn = document.getElementById('btn-reconstruct');
        
        if (!isReconstructMode) {
            // Start Mode
            if (!pdfDoc) { alert("Load a PDF first."); return; }
            
            isReconstructMode = true;
            btn.innerHTML = '<i class="fas fa-check"></i>&nbsp;Finish & Scan';
            btn.classList.add('reconstruct-active');
            
            showMsg("Step 1: Draw boxes around images/diagrams you want to KEEP.");
            setTool('reconstruct'); // Activates custom mouse events
            
        } else {
            // Finish Mode -> Execute
            if (!confirm("Are you done selecting safe zones?")) return;
            executeReconstruction();
        }
    }

    function resetReconstructUI() {
        const btn = document.getElementById('btn-reconstruct');
        btn.innerHTML = '<i class="fas fa-magic"></i>&nbsp;Reconstruct';
        btn.classList.remove('reconstruct-active');
        isReconstructMode = false;
        showMsg("");
        
        // Remove temporary selection rects
        fabricCanvases.forEach(canvas => {
            const objects = canvas.getObjects();
            objects.forEach(o => {
                if (o.data && o.data.isSafeZone) canvas.remove(o);
            });
            canvas.renderAll();
        });
        setTool('select');
    }

    function handleReconstructMouseDown(canvas, opt) {
        if (!isReconstructMode) return;
        const pointer = canvas.getPointer(opt.e);
        reconstructMouseStart = { x: pointer.x, y: pointer.y };
        
        const rect = new fabric.Rect({
            left: pointer.x, top: pointer.y,
            width: 0, height: 0,
            fill: 'rgba(46, 204, 113, 0.2)',
            stroke: '#2ecc71', strokeWidth: 2,
            selectable: false, evented: false,
            data: { isSafeZone: true }
        });
        
        reconstructActiveRect = rect;
        canvas.add(rect);
    }

    function handleReconstructMouseMove(canvas, opt) {
        if (!isReconstructMode || !reconstructActiveRect) return;
        const pointer = canvas.getPointer(opt.e);
        
        if(reconstructMouseStart.x > pointer.x){
            reconstructActiveRect.set({ left: pointer.x });
        }
        if(reconstructMouseStart.y > pointer.y){
            reconstructActiveRect.set({ top: pointer.y });
        }
        
        reconstructActiveRect.set({
            width: Math.abs(reconstructMouseStart.x - pointer.x),
            height: Math.abs(reconstructMouseStart.y - pointer.y)
        });
        canvas.renderAll();
    }

    function handleReconstructMouseUp(canvas) {
        if (!isReconstructMode) return;
        reconstructActiveRect = null;
        // Don't save history for selection boxes
    }

    async function executeReconstruction() {
        const canvas = getActiveCanvas();
        if (!canvas) return;

        // 1. Gather Configuration
        const lang = document.getElementById('ocr-lang').value;
        // Ask for BG Color using a temporary input or prompt? 
        // User asked for "asks you to choose bg colour".
        // Let's use a browser color picker dialog approach or simple prompt. 
        // For better UI, we can use the existing color picker but prompt user to set it first?
        // Let's assume standard white or ask via prompt for hex.
        const defaultBg = "#ffffff";
        let bgColor = prompt("Enter Background Color (Hex, e.g. #ffffff):", defaultBg);
        if(!bgColor) bgColor = defaultBg;

        showLoader(true, "Scanning & Reconstructing...");

        try {
            const pageIndex = fabricCanvases.indexOf(canvas);
            const wrapper = document.querySelectorAll('.page-container')[pageIndex];
            const pdfCanvas = wrapper.querySelector('.pdf-canvas'); // The original image source
            const ctx = pdfCanvas.getContext('2d');

            // 2. Extract Safe Zones (Images)
            const safeZoneObjects = canvas.getObjects().filter(o => o.data && o.data.isSafeZone);
            const preservedImages = [];

            for (let obj of safeZoneObjects) {
                // Get image data from original PDF canvas at these coordinates
                // We need to account for scaling if any, but usually they match 1:1 in this setup
                const x = obj.left;
                const y = obj.top;
                const w = obj.width * obj.scaleX;
                const h = obj.height * obj.scaleY;

                const imgData = ctx.getImageData(x, y, w, h);
                
                // Create a temp canvas to convert to data URL
                const tempC = document.createElement('canvas');
                tempC.width = w;
                tempC.height = h;
                tempC.getContext('2d').putImageData(imgData, 0, 0);
                
                preservedImages.push({
                    url: tempC.toDataURL(),
                    left: x,
                    top: y,
                    width: w,
                    height: h
                });
            }

            // 3. Prepare Image for OCR (Masking Safe Zones)
            // We draw the PDF to a temp canvas, then draw WHITE rectangles over safe zones
            // so OCR ignores them.
            const ocrCanvas = document.createElement('canvas');
            ocrCanvas.width = pdfCanvas.width;
            ocrCanvas.height = pdfCanvas.height;
            const ocrCtx = ocrCanvas.getContext('2d');
            ocrCtx.drawImage(pdfCanvas, 0, 0);
            
            ocrCtx.fillStyle = bgColor; // Mask with bg color
            safeZoneObjects.forEach(obj => {
                ocrCtx.fillRect(
                    obj.left, obj.top, 
                    obj.width * obj.scaleX, obj.height * obj.scaleY
                );
            });

            const ocrImgUrl = ocrCanvas.toDataURL('image/png');

            // 4. Run OCR
            const { data: { lines } } = await Tesseract.recognize(ocrImgUrl, lang);

            // 5. Reconstruct Page
            // A. Clear Fabric Canvas completely
            canvas.clear(); 
            canvas.setBackgroundColor(bgColor, canvas.renderAll.bind(canvas));
            
            // B. Hide original PDF background (Replace logic)
            pdfCanvas.style.display = 'none';

            // C. Place Preserved Images
            preservedImages.forEach(img => {
                fabric.Image.fromURL(img.url, function(oImg) {
                    oImg.set({
                        left: img.left,
                        top: img.top,
                        selectable: true
                    });
                    canvas.add(oImg);
                });
            });

            // D. Place Extracted Text
            lines.forEach(line => {
                // Filter out empty lines or low confidence if needed
                if(line.text.trim().length < 2) return;

                const textObj = new fabric.IText(line.text, {
                    left: line.bbox.x0,
                    top: line.bbox.y0,
                    fontSize: (line.bbox.y1 - line.bbox.y0) * 0.8, // Estimate font size height
                    fontFamily: 'Arial',
                    fill: document.getElementById('draw-color').value, // Use current color or black
                    width: line.bbox.x1 - line.bbox.x0
                });
                canvas.add(textObj);
            });

            // Finish
            canvas.renderAll();
            saveHistory(pageIndex);
            
            resetReconstructUI();
            alert("Reconstruction Complete! Elements are now editable.");

        } catch (e) {
            console.error(e);
            alert("Reconstruction failed: " + e.message);
            resetReconstructUI();
        } finally {
            showLoader(false);
        }
    }

    // --- Standard Tools ---

    function getActiveCanvas() {
        const wrappers = document.querySelectorAll('.page-container');
        let bestIndex = 0;
        let maxVisible = 0;
        
        wrappers.forEach((w, i) => {
            const rect = w.getBoundingClientRect();
            const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
            if (visibleHeight > maxVisible) {
                maxVisible = visibleHeight;
                bestIndex = i;
            }
        });
        
        return fabricCanvases[bestIndex];
    }

    function addShape(type) {
        const canvas = getActiveCanvas();
        if(!canvas) return;
        setTool('select');
        
        const color = document.getElementById('draw-color').value;
        const center = { left: canvas.width / 2, top: canvas.height / 2 }; 
        const commonProps = { 
            left: center.left, top: center.top, originX: 'center', originY: 'center',
            stroke: color, strokeWidth: 3, fill: 'transparent' 
        };

        let obj;
        if (type === 'rect') obj = new fabric.Rect({ ...commonProps, width: 100, height: 100 });
        else if (type === 'circle') obj = new fabric.Circle({ ...commonProps, radius: 50 });

        canvas.add(obj);
        canvas.setActiveObject(obj);
        saveHistory(fabricCanvases.indexOf(canvas));
    }

    function addText() {
        const canvas = getActiveCanvas();
        if(!canvas) return;
        setTool('select');
        
        const color = document.getElementById('draw-color').value;
        const size = parseInt(document.getElementById('text-size').value);
        
        const text = new fabric.IText('Double click to edit', {
            left: canvas.width / 2, top: canvas.height / 2,
            fontFamily: 'Arial', fill: color, fontSize: size,
            originX: 'center', originY: 'center'
        });
        
        canvas.add(text);
        canvas.setActiveObject(text);
        saveHistory(fabricCanvases.indexOf(canvas));
    }

    function deleteSelected() {
        const canvas = getActiveCanvas();
        if (!canvas) return;
        const activeObj = canvas.getActiveObject();
        if (activeObj) {
            canvas.remove(activeObj);
            saveHistory(fabricCanvases.indexOf(canvas));
        }
    }

    // --- Image Upload ---
    function handleImageUpload(input) {
        const file = input.files[0];
        if (!file) return;
        const canvas = getActiveCanvas();
        if (!canvas) return;

        const reader = new FileReader();
        reader.onload = function(f) {
            fabric.Image.fromURL(f.target.result, function(img) {
                img.scaleToWidth(200);
                img.set({ left: canvas.width/2, top: canvas.height/2, originX:'center', originY:'center' });
                canvas.add(img);
                canvas.setActiveObject(img);
                input.value = '';
                saveHistory(fabricCanvases.indexOf(canvas));
            });
        };
        reader.readAsDataURL(file);
    }

    // --- Standard Auto Highlight ---
    async function runAutoHighlight() {
        const canvas = getActiveCanvas();
        if(!canvas) return;
        const lang = document.getElementById('ocr-lang').value;
        
        showLoader(true, "Auto-Highlighting...");
        try {
            const pageIndex = fabricCanvases.indexOf(canvas);
            const wrapper = document.querySelectorAll('.page-container')[pageIndex];
            const pdfCanvas = wrapper.querySelector('.pdf-canvas');
            
            const { data: { lines } } = await Tesseract.recognize(pdfCanvas.toDataURL(), lang);
            
            lines.forEach(line => {
                const rect = new fabric.Rect({
                    left: line.bbox.x0, top: line.bbox.y0,
                    width: line.bbox.x1 - line.bbox.x0, height: line.bbox.y1 - line.bbox.y0,
                    fill: document.getElementById('draw-color').value,
                    opacity: 0.3,
                    data: { isHighlight: true }
                });
                canvas.add(rect);
            });
            saveHistory(pageIndex);
        } catch(e) { console.error(e); alert("OCR Error"); } 
        finally { showLoader(false); }
    }

    // --- History & Export ---
    function saveHistory(pageIndex) {
        if(historyStep < history.length - 1) history = history.slice(0, historyStep + 1);
        const state = JSON.stringify(fabricCanvases[pageIndex].toJSON(['data', 'selectable', 'evented']));
        history.push({ pageIndex, state });
        historyStep++;
    }

    function undo() {
        if (historyStep > 0) {
            historyStep--;
            const { pageIndex, state } = history[historyStep];
            fabricCanvases[pageIndex].loadFromJSON(JSON.parse(state), () => fabricCanvases[pageIndex].renderAll());
        }
    }

    function redo() {
        if (historyStep < history.length - 1) {
            historyStep++;
            const { pageIndex, state } = history[historyStep];
            fabricCanvases[pageIndex].loadFromJSON(JSON.parse(state), () => fabricCanvases[pageIndex].renderAll());
        }
    }

    async function exportPDF() {
        if (!originalPdfBytes) return;
        showLoader(true, "Exporting...");
        try {
            const { PDFDocument, rgb } = PDFLib;
            const pdfDoc = await PDFDocument.load(originalPdfBytes);
            const pages = pdfDoc.getPages();

            for (let i = 0; i < pages.length; i++) {
                const fabricCanvas = fabricCanvases[i];
                // Check if background was modified (Reconstruction happened)
                const isReconstructed = fabricCanvas.backgroundColor;

                // Capture the fabric layer as image
                const dataUrl = fabricCanvas.toDataURL({ format: 'png', multiplier: 2 });
                const pngImage = await pdfDoc.embedPng(dataUrl);
                const page = pages[i];
                const { width, height } = page.getSize();

                // If reconstructed, we essentially cover the old page with our new canvas
                // Since our canvas has the opaque background color set during reconstruction
                // it will act as a replacement.
                page.drawImage(pngImage, { x: 0, y: 0, width: width, height: height });
            }

            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = (document.getElementById('filename-input').value || 'edited') + '.pdf';
            link.click();
        } catch (e) { alert("Export Error: " + e.message); } 
        finally { showLoader(false); }
    }

    // --- Helpers ---
    function showLoader(show, text) {
        document.getElementById('loader').style.display = show ? 'flex' : 'none';
        if(text) document.getElementById('loader-text').innerText = text;
    }
    
    function showMsg(text) {
        const el = document.getElementById('msg-overlay');
        el.innerText = text;
        if(text) el.classList.add('visible');
        else el.classList.remove('visible');
    }

    function updateBrush() {
        if(currentTool === 'marker' || currentTool === 'highlighter_manual') setTool(currentTool);
    }
    
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }
</script>
<script>
(() => {
  const STORAGE_KEY = "docuwritepro_tips_markup_seen";
  if (localStorage.getItem(STORAGE_KEY)) return;

  const tips = [
    "Welcome to the Markup Tool. Use this tool to edit already edited PDFs.",
    "Use the import button to import and export button to export PDFs.",
    "Use the drag icon to scroll and cursor icon to select.",
    "Use the redo and undo button to redo/undo. Use the delete button to delete any selected element.",
    "Use the marker and highlighter tools to apply highlight of that colour. Choose the desired colour and size from the colour and size chooser.",
    "Use the square or circle tools to draw shapes. Click the insert text button to insert a text element.",
    "Use the insert image tool to insert images from your device.",
    "Choose the language and click Auto to auto highlight over text. Delete or resize highlights as your need.",
    "Use the Reconstruct button to make an uneditable page editable again.",
    "To create a new document from scratch, use the Editor tool."
  ];

  let index = 0;
  let direction = 1;

  /* Container */
  const box = document.createElement("div");
  box.id = "dwp-tip-box";
  box.innerHTML = `
    <div class="dwp-progress">
      <div class="dwp-progress-bar"></div>
    </div>

    <div class="dwp-tip-wrapper">
      <div class="dwp-tip-text"></div>
    </div>

    <div class="dwp-actions">
      <button class="dwp-prev">Back</button>
      <button class="dwp-next">Next</button>
    </div>
  `;
  document.body.appendChild(box);

  const textEl = box.querySelector(".dwp-tip-text");
  const nextBtn = box.querySelector(".dwp-next");
  const prevBtn = box.querySelector(".dwp-prev");
  const progressBar = box.querySelector(".dwp-progress-bar");

  function updateTip(animate = true) {
    if (animate) {
      textEl.classList.remove("slide-in-left", "slide-in-right");
      void textEl.offsetWidth;
      textEl.classList.add(direction > 0 ? "slide-in-right" : "slide-in-left");
    }

    textEl.textContent = tips[index];
    progressBar.style.width = `${((index + 1) / tips.length) * 100}%`;

    prevBtn.style.visibility = index === 0 ? "hidden" : "visible";
    nextBtn.textContent = index === tips.length - 1 ? "Got it" : "Next";
  }

  nextBtn.onclick = () => {
    if (index === tips.length - 1) {
      localStorage.setItem(STORAGE_KEY, "true");
      box.classList.add("fade-out");
      setTimeout(() => box.remove(), 300);
    } else {
      direction = 1;
      index++;
      updateTip();
    }
  };

  prevBtn.onclick = () => {
    if (index > 0) {
      direction = -1;
      index--;
      updateTip();
    }
  };

  setTimeout(() => {
    box.classList.add("show");
    updateTip(false);
  }, 1000);

  /* Styles */
  const style = document.createElement("style");
  style.textContent = `
    #dwp-tip-box {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 320px;
      background: #1e6bff;
      color: #fff;
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 35px rgba(0,0,0,.25);
      font-family: Inter, system-ui, sans-serif;
      z-index: 99999;
      opacity: 0;
      transform: translateY(-6px);
      transition: opacity .3s ease, transform .3s ease;
    }

    #dwp-tip-box.show {
      opacity: 1;
      transform: translateY(0);
    }

    #dwp-tip-box.fade-out {
      opacity: 0;
      transform: translateY(-6px);
    }

    .dwp-progress {
      height: 4px;
      background: rgba(255,255,255,.25);
      border-radius: 99px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .dwp-progress-bar {
      height: 100%;
      width: 0%;
      background: #fff;
      transition: width .35s ease;
    }

    .dwp-tip-wrapper {
      overflow: hidden;
      min-height: 48px;
    }

    .dwp-tip-text {
      font-size: 14px;
      line-height: 1.55;
    }

    .slide-in-right {
      animation: slideRight .25s ease;
    }

    .slide-in-left {
      animation: slideLeft .25s ease;
    }

    @keyframes slideRight {
      from { opacity: 0; transform: translateX(14px); }
      to { opacity: 1; transform: translateX(0); }
    }

    @keyframes slideLeft {
      from { opacity: 0; transform: translateX(-14px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .dwp-actions {
      display: flex;
      justify-content: space-between;
      margin-top: 14px;
    }

    .dwp-actions button {
      border: none;
      padding: 6px 14px;
      border-radius: 7px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
    }

    .dwp-prev {
      background: rgba(255,255,255,.25);
      color: #fff;
    }

    .dwp-next {
      background: #fff;
      color: #1e6bff;
    }
  `;
  document.head.appendChild(style);
})();
</script>

    
</body>
</html>
