<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opensheet | Spreadsheet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
    <style>
        :root {
            --grid-border: #e2e8f0;
            --header-bg: #f8fafc;
            --selection-bg: rgba(79, 70, 229, 0.08);
            --selection-border: #4f46e5;
            --dependency-bg: rgba(16, 185, 129, 0.1);
            --dependency-border: #10b981;
        }

        body {
            font-family: 'Inter', sans-serif;
            overflow-y: auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            color: #1e293b;
        }

        .spreadsheet-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #f1f5f9;
        }

        table {
            border-collapse: separate;
            border-spacing: 0;
            table-layout: fixed;
            background: white;
        }

        th, td {
            border-right: 1px solid var(--grid-border);
            border-bottom: 1px solid var(--grid-border);
            position: relative;
            min-width: 100px;
            height: 28px;
            padding: 0 8px;
            font-size: 13px;
            outline: none;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        th {
            background: var(--header-bg);
            font-weight: 500;
            color: #64748b;
            user-select: none;
            text-align: center;
        }

        .row-header {
            width: 50px;
            min-width: 50px;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .col-header {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .corner-header {
            position: sticky;
            top: 0;
            left: 0;
            z-index: 20;
            background: #cbd5e1;
            width: 50px;
        }

        td.selected {
            background: var(--selection-bg);
            box-shadow: inset 0 0 0 2px var(--selection-border);
            z-index: 5;
        }

        td.dependency-highlight {
            background: var(--dependency-bg);
            box-shadow: inset 0 0 0 1px var(--dependency-border);
            z-index: 4;
        }

        .toolbar {
            background: white;
            border-bottom: 1px solid var(--grid-border);
            padding: 8px 12px;
            display: flex;
            gap: 4px;
            align-items: center;
            overflow-x: auto;
            flex-shrink: 0;
        }

        .tool-btn {
            padding: 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            color: #475569;
        }

        .tool-btn:hover, .tool-btn.active {
            background: #f1f5f9;
            color: #4f46e5;
        }

        .divider {
            width: 1px;
            height: 20px;
            background: var(--grid-border);
            margin: 0 6px;
        }

        input[type="color"] {
            width: 20px;
            height: 20px;
            border: none;
            padding: 0;
            background: none;
            cursor: pointer;
        }

        #file-input { display: none; }
    </style>
</head>
<body class="bg-slate-50">

    <header class="bg-white px-4 py-2 flex items-center justify-between border-b shadow-sm z-30">
        <div class="flex items-center gap-4">
            <div class="bg-indigo-600 p-1.5 rounded-lg shadow-inner">
                <span class="material-symbols-outlined text-white text-xl leading-none block">grid_view</span>
            </div>
            <input type="text" id="sheet-title" value="Spreadsheet" class="text-lg font-semibold outline-none border-b-2 border-transparent focus:border-indigo-500 transition-all px-1 bg-transparent">
        </div>
        <div class="flex gap-2">
<div class="flex items-center gap-2 px-3 py-1.5 border border-slate-300 rounded-md bg-white">
    <span class="text-xs font-semibold text-slate-500 uppercase tracking-wider">Auto Select</span>
    <button id="auto-select-toggle" onclick="toggleAutoSelect()" class="relative inline-flex h-5 w-9 items-center rounded-full bg-slate-200 transition-colors focus:outline-none">
        <span id="toggle-dot" class="inline-block h-3 w-3 transform rounded-full bg-white transition-transform translate-x-1"></span>
    </button>
</div>
            <button onclick="document.getElementById('file-input').click()" class="px-3 py-1.5 border border-slate-300 rounded-md text-sm font-medium hover:bg-slate-100 transition-all flex items-center gap-2">
                <span class="material-symbols-outlined text-sm">upload_file</span> Import
            </button>
            <div class="relative group">
                <button class="px-4 py-1.5 bg-indigo-600 text-white rounded-md text-sm font-medium hover:bg-indigo-700 transition-all flex items-center gap-2">
                    <span class="material-symbols-outlined text-sm">download</span> Export
                </button>
                <div class="absolute right-0 mt-1 w-48 bg-white border border-slate-200 rounded shadow-lg hidden group-hover:block z-50">
                    <button onclick="exportFile('json')" class="w-full text-left px-4 py-2 text-sm hover:bg-slate-50 flex items-center gap-2">
                        <span class="material-symbols-outlined text-sm text-indigo-500">data_object</span> Save as JSON
                    </button>
                    <button onclick="exportFile('csv')" class="w-full text-left px-4 py-2 text-sm hover:bg-slate-50 flex items-center gap-2 border-t border-slate-100">
                        <span class="material-symbols-outlined text-sm text-slate-500">csv</span> Export as CSV
                    </button>
                </div>
            </div>
        </div>
    </header>

    <input type="file" id="file-input" accept=".json,.csv" onchange="importFile(event)">

    <div class="toolbar">
        <div class="tool-btn" onclick="undo()" title="Undo"><span class="material-symbols-outlined">undo</span></div>
        <div class="tool-btn" onclick="redo()" title="Redo"><span class="material-symbols-outlined">redo</span></div>
        <div class="divider"></div>
        <div class="tool-btn" onclick="addRow()" title="Add Row Below"><span class="material-symbols-outlined">add_row_below</span></div>
        <div class="tool-btn" onclick="addCol()" title="Add Column Right"><span class="material-symbols-outlined">add_column_right</span></div>
        <div class="divider"></div>
        <div class="tool-btn" id="btn-bold" onclick="applyStyle('fontWeight', 'bold')" title="Bold"><span class="material-symbols-outlined">format_bold</span></div>
        <div class="tool-btn" id="btn-italic" onclick="applyStyle('fontStyle', 'italic')" title="Italic"><span class="material-symbols-outlined">format_italic</span></div>
        <div class="tool-btn" id="btn-underline" onclick="applyStyle('textDecoration', 'underline')" title="Underline"><span class="material-symbols-outlined">format_underlined</span></div>
        <div class="divider"></div>
        <div class="tool-btn" onclick="applyStyle('textAlign', 'left')"><span class="material-symbols-outlined">format_align_left</span></div>
        <div class="tool-btn" onclick="applyStyle('textAlign', 'center')"><span class="material-symbols-outlined">format_align_center</span></div>
        <div class="tool-btn" onclick="applyStyle('textAlign', 'right')"><span class="material-symbols-outlined">format_align_right</span></div>
        <div class="divider"></div>
        <div class="flex items-center gap-1 px-2 hover:bg-slate-100 rounded cursor-pointer h-8">
            <span class="material-symbols-outlined text-sm">palette</span>
            <input type="color" onchange="applyStyle('color', this.value)" title="Text Color">
        </div>
        <div class="flex items-center gap-1 px-2 hover:bg-slate-100 rounded cursor-pointer h-8">
            <span class="material-symbols-outlined text-sm">format_color_fill</span>
            <input type="color" id="bg-color-input" onchange="applyStyle('backgroundColor', this.value)" value="#ffffff" title="Cell Background">
        </div>
        <div class="divider"></div>
        <button onclick="deleteCurrentRow()" class="text-xs px-2 py-1 bg-red-50 text-red-600 rounded hover:bg-red-100 transition-colors">Delete Row</button>
        <button onclick="deleteCurrentCol()" class="text-xs px-2 py-1 bg-red-50 text-red-600 rounded hover:bg-red-100 transition-colors ml-1">Delete Col</button>
    </div>

    <div class="formula-bar flex border-b bg-white items-center px-3 py-1 gap-2 shadow-sm z-20">
        <div id="active-cell-id" class="text-xs font-mono font-bold text-indigo-600 min-w-[50px] px-2 py-1 bg-indigo-50 border border-indigo-100 rounded text-center">A1</div>
        <div class="text-slate-300 font-light text-xl">|</div>
        <span class="material-symbols-outlined text-slate-400 text-sm">function</span>
        <input type="text" id="formula-input" class="flex-1 outline-none text-sm font-medium py-1 px-2 focus:bg-slate-50 rounded transition-colors" placeholder="Enter value or formula (e.g., =SUM(A1:A10))">
    </div>

    <div class="spreadsheet-container" id="drop-zone">
        <table id="main-grid">
            <thead id="grid-head"></thead>
            <tbody id="grid-body"></tbody>
        </table>
    </div>

    <footer class="bg-white border-t px-4 py-2 text-[10px] text-slate-400 flex justify-between uppercase tracking-widest font-bold">
        <div id="status-text">Ready</div>
        <div id="grid-dimensions">0 Rows x 0 Cols</div>
    </footer>

    <script>
        let rows = 40;
        let cols = 20;
        let cellData = {}; 
        let activeCell = { r: 0, c: 0 };
        let history = [];
        let historyIndex = -1;

        // --- Core Helpers ---
        function getColLabel(index) {
            let label = "";
            while (index >= 0) {
                label = String.fromCharCode((index % 26) + 65) + label;
                index = Math.floor(index / 26) - 1;
            }
            return label;
        }

        function getCellId(r, c) { return `${getColLabel(c)}${r + 1}`; }

        function parseCellId(id) {
            const match = id.match(/([A-Z]+)(\d+)/);
            if (!match) return null;
            let colLabel = match[1], row = parseInt(match[2]) - 1, col = 0;
            for (let i = 0; i < colLabel.length; i++) col = col * 26 + (colLabel.charCodeAt(i) - 64);
            return { r: row, c: col - 1 };
        }

        // --- Grid Management ---
        function renderGrid() {
            const head = document.getElementById('grid-head');
            const body = document.getElementById('grid-body');
            head.innerHTML = `<tr><th class="corner-header"></th>${Array.from({length: cols}, (_, c) => `<th class="col-header">${getColLabel(c)}</th>`).join('')}</tr>`;

            let bHtml = "";
            for (let r = 0; r < rows; r++) {
                bHtml += `<tr><th class="row-header">${r + 1}</th>`;
                for (let c = 0; c < cols; c++) {
                    const id = getCellId(r, c);
                    const data = cellData[id] || { display: '', style: {} };
                    const styleStr = buildStyleString(data.style || {});
                    bHtml += `<td id="${id}" contenteditable="true" style="${styleStr}" onfocus="onCellFocus(${r}, ${c})" onblur="onCellBlur('${id}')" onkeydown="onCellKey(event, ${r}, ${c})">${data.display || ''}</td>`;
                }
                bHtml += `</tr>`;
            }
            body.innerHTML = bHtml;
            document.getElementById('grid-dimensions').innerText = `${rows} Rows x ${cols} Cols`;
        }

        function buildStyleString(styleObj) {
            return Object.entries(styleObj).map(([k,v]) => `${k.replace(/[A-Z]/g, m => "-" + m.toLowerCase())}:${v}`).join(';');
        }

        // --- Cell Logic ---
        function onCellFocus(r, c) {
            clearHighlights();
            const prevId = getCellId(activeCell.r, activeCell.c);
            document.getElementById(prevId)?.classList.remove('selected');

            activeCell = { r, c };
            const id = getCellId(r, c);
            const td = document.getElementById(id);
            td.classList.add('selected');
            document.getElementById('active-cell-id').innerText = id;
            
            const data = cellData[id] || { raw: '' };
            if (data.raw && data.raw.toString().startsWith('=')) {
                td.innerText = data.raw;
                highlightDependencies(data.raw);
            }
            document.getElementById('formula-input').value = data.raw || td.innerText;
        }

        function onCellBlur(id) {
            const td = document.getElementById(id);
            updateCellValue(id, td.innerText);
            recalculateAll();
        }

        function updateCellValue(id, val) {
            if (!cellData[id]) cellData[id] = { raw: '', display: '', style: {} };
            const oldRaw = cellData[id].raw;
            cellData[id].raw = val;
            if (oldRaw !== val) saveHistory();
        }

        function onCellKey(e, r, c) {
            if (e.key === 'Enter') { e.preventDefault(); moveFocus(r + 1, c); }
            if (e.key === 'Tab') { e.preventDefault(); moveFocus(r, c + 1); }
        }

        function moveFocus(r, c) {
            const id = getCellId(Math.max(0, Math.min(r, rows-1)), Math.max(0, Math.min(c, cols-1)));
            document.getElementById(id)?.focus();
        }

        document.getElementById('formula-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const id = getCellId(activeCell.r, activeCell.c);
                updateCellValue(id, e.target.value);
                recalculateAll();
                document.getElementById(id).focus();
            }
        });

        // --- Styles ---
        function applyStyle(prop, val) {
            const id = getCellId(activeCell.r, activeCell.c);
            const td = document.getElementById(id);
            if (!td) return;
            
            if (!cellData[id]) cellData[id] = { raw: td.innerText, display: td.innerText, style: {} };
            
            // Toggle Logic for simple styles
            if (prop === 'fontWeight') val = td.style.fontWeight === 'bold' ? 'normal' : 'bold';
            else if (prop === 'fontStyle') val = td.style.fontStyle === 'italic' ? 'normal' : 'italic';
            else if (prop === 'textDecoration') val = td.style.textDecoration.includes('underline') ? 'none' : 'underline';
            
            td.style[prop] = val;
            cellData[id].style[prop] = val;
            saveHistory();
        }

        // --- Formula Engine ---
        function clearHighlights() {
            document.querySelectorAll('.dependency-highlight').forEach(el => el.classList.remove('dependency-highlight'));
        }

        function highlightDependencies(formula) {
            extractCellReferences(formula).forEach(id => {
                document.getElementById(id)?.classList.add('dependency-highlight');
            });
        }

        function extractCellReferences(formula) {
            const refs = new Set(), upper = formula.toString().toUpperCase();
            const rangeRegex = /([A-Z]+\d+):([A-Z]+\d+)/g;
            let match;
            while ((match = rangeRegex.exec(upper)) !== null) {
                const start = parseCellId(match[1]), end = parseCellId(match[2]);
                if (start && end) {
                    for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++)
                        for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++)
                            refs.add(getCellId(r, c));
                }
            }
            const cellRegex = /\b[A-Z]+\d+\b/g;
            while ((match = cellRegex.exec(upper)) !== null) {
                const id = match[0];
                const prev = upper[match.index - 1], next = upper[match.index + id.length];
                if (prev !== ':' && next !== ':') refs.add(id);
            }
            return Array.from(refs);
        }

        function recalculateAll() {
            const ids = Object.keys(cellData);
            for(let i = 0; i < 8; i++) { 
                let changed = false;
                ids.forEach(id => {
                    const item = cellData[id];
                    let newVal;
                    if (item.raw && item.raw.toString().startsWith('=')) {
                        newVal = executeFormula(item.raw);
                    } else {
                        newVal = item.raw;
                    }
                    if (item.display !== newVal) {
                        item.display = newVal;
                        changed = true;
                    }
                    const td = document.getElementById(id);
                    if (td && document.activeElement !== td) td.innerText = item.display;
                });
                if (!changed) break;
            }
        }

        function executeFormula(raw) {
            try {
                let expr = raw.substring(1).toUpperCase();
                const funcRegex = /(SUM|AVERAGE|COUNT|MIN|MAX)\(([A-Z0-9:]+)\)/g;
                expr = expr.replace(funcRegex, (m, func, range) => {
                    const vals = getRangeValues(range);
                    if (func === 'SUM') return vals.reduce((a, b) => a + b, 0);
                    if (func === 'AVERAGE') return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
                    if (func === 'COUNT') return vals.length;
                    if (func === 'MIN') return vals.length ? Math.min(...vals) : 0;
                    if (func === 'MAX') return vals.length ? Math.max(...vals) : 0;
                });
                expr = expr.replace(/\b[A-Z]+\d+\b/g, (m) => {
                    const val = cellData[m]?.display || "0";
                    return isNaN(val) || val === "" ? 0 : val;
                });
                if (/[^0-9+\-*/().\s]/.test(expr)) return "#REF!";
                const res = eval(expr);
                return isFinite(res) ? Math.round(res * 100) / 100 : "#ERR";
            } catch { return "#VAL"; }
        }

        function getRangeValues(rangeStr) {
            if (!rangeStr.includes(':')) {
                const v = parseFloat(cellData[rangeStr]?.display);
                return isNaN(v) ? [] : [v];
            }
            const [sId, eId] = rangeStr.split(':'), start = parseCellId(sId), end = parseCellId(eId);
            if (!start || !end) return [];
            const vals = [];
            for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++)
                for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++) {
                    const v = parseFloat(cellData[getCellId(r, c)]?.display);
                    if (!isNaN(v)) vals.push(v);
                }
            return vals;
        }

        // --- Grid Mutations ---
        function addRow() { rows++; renderGrid(); recalculateAll(); saveHistory(); }
        function addCol() { cols++; renderGrid(); recalculateAll(); saveHistory(); }
        function deleteCurrentRow() {
            if (rows <= 1) return;
            const r = activeCell.r;
            const newData = {};
            Object.keys(cellData).forEach(id => {
                const cell = parseCellId(id);
                if (cell.r < r) newData[id] = cellData[id];
                else if (cell.r > r) newData[getCellId(cell.r - 1, cell.c)] = cellData[id];
            });
            cellData = newData;
            rows--;
            renderGrid(); recalculateAll(); saveHistory();
        }
        function deleteCurrentCol() {
            if (cols <= 1) return;
            const c = activeCell.c;
            const newData = {};
            Object.keys(cellData).forEach(id => {
                const cell = parseCellId(id);
                if (cell.c < c) newData[id] = cellData[id];
                else if (cell.c > c) newData[getCellId(cell.r, cell.c - 1)] = cellData[id];
            });
            cellData = newData;
            cols--;
            renderGrid(); recalculateAll(); saveHistory();
        }

        // --- Persistence ---
        function exportFile(type) {
            const title = document.getElementById('sheet-title').value || 'spreadsheet';
            let content, mime, ext;

            if (type === 'json') {
                content = JSON.stringify({ 
                    title, 
                    rows, 
                    cols, 
                    cellData 
                }, null, 4);
                mime = 'application/json';
                ext = 'json';
            } else {
                let csvRows = [];
                for (let r = 0; r < rows; r++) {
                    let csvRow = [];
                    for (let c = 0; c < cols; c++) {
                        csvRow.push(`"${(cellData[getCellId(r, c)]?.display || "").toString().replace(/"/g, '""')}"`);
                    }
                    csvRows.push(csvRow.join(','));
                }
                content = csvRows.join('\n');
                mime = 'text/csv';
                ext = 'csv';
            }

            const blob = new Blob([content], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${title}.${ext}`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importFile(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const text = event.target.result;
                const fileName = file.name.toLowerCase();

                if (fileName.endsWith('.json')) {
                    try {
                        const data = JSON.parse(text);
                        rows = data.rows || 40;
                        cols = data.cols || 20;
                        cellData = data.cellData || {};
                        document.getElementById('sheet-title').value = data.title || 'Untitled Spreadsheet';
                        
                        renderGrid(); 
                        recalculateAll(); 
                        saveHistory();
                        document.getElementById('status-text').innerText = "JSON Loaded";
                    } catch (err) { alert("Invalid JSON file"); }
                } else if (fileName.endsWith('.csv')) {
                    const csvLines = text.split(/\r?\n/).filter(line => line.trim() !== "");
                    cellData = {};
                    rows = Math.max(40, csvLines.length);
                    cols = 20;
                    csvLines.forEach((line, r) => {
                        const rowCells = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                        cols = Math.max(cols, rowCells.length);
                        rowCells.forEach((val, c) => {
                            const cleanVal = val.replace(/^"|"$/g, '').replace(/""/g, '"');
                            if (cleanVal) cellData[getCellId(r, c)] = { raw: cleanVal, display: cleanVal, style: {} };
                        });
                    });
                    renderGrid(); recalculateAll(); saveHistory();
                    document.getElementById('status-text').innerText = "CSV Loaded";
                }
                e.target.value = ''; // Reset file input
            };
            reader.readAsText(file);
        }

        // --- History / Undo ---
        function saveHistory() {
            const snap = JSON.stringify({ rows, cols, cellData });
            if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
            history.push(snap);
            historyIndex++;
            if (history.length > 50) history.shift();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(JSON.parse(history[historyIndex]));
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(JSON.parse(history[historyIndex]));
            }
        }

        function restoreState(state) {
            rows = state.rows; cols = state.cols; cellData = state.cellData;
            renderGrid(); recalculateAll();
        }

        window.onload = () => { renderGrid(); saveHistory(); };
    </script>
<script>
    /**
     * Fixed IF Logic for Opensheet
     * Now correctly passes MIN, MAX, COUNT, etc., to the base engine.
     */
    const baseExecuteFormula = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase();
            
            // 1. Process IF logic first
            const ifRegex = /IF\(([A-Z]+\d+)\s*([>=<]+|!=)\s*([A-Z0-9.]+)\s*,\s*([^,)]+)(?:\s*,\s*([^)]+))?\)/g;
            
            if (expr.includes("IF(")) {
                expr = expr.replace(ifRegex, (match, leftCell, operator, rightSide, truePart, falsePart) => {
                    const leftVal = parseFloat(cellData[leftCell]?.display) || 0;
                    let rightVal = /^[A-Z]+\d+$/.test(rightSide) ? (parseFloat(cellData[rightSide]?.display) || 0) : (parseFloat(rightSide) || 0);

                    let conditionMet = false;
                    switch(operator) {
                        case '>':  conditionMet = leftVal > rightVal; break;
                        case '<':  conditionMet = leftVal < rightVal; break;
                        case '>=': conditionMet = leftVal >= rightVal; break;
                        case '<=': conditionMet = leftVal <= rightVal; break;
                        case '=':  conditionMet = leftVal === rightVal; break;
                        case '!=': conditionMet = leftVal !== rightVal; break;
                    }

                    const resultPart = conditionMet ? truePart.trim() : (falsePart ? falsePart.trim() : "");
                    if (/^["'].*["']$/.test(resultPart)) return resultPart.replace(/["']/g, "");
                    if (/^[A-Z]+\d+$/.test(resultPart)) return cellData[resultPart]?.display || "";
                    return resultPart;
                });
            }

            // 2. THE FIX: Check if the expression contains ANY math or built-in functions
            // This list now includes SUM, AVERAGE, COUNT, MIN, and MAX
            const builtInFunctions = /(SUM|AVERAGE|COUNT|MIN|MAX)/;
            if (builtInFunctions.test(expr) || /[\+\-\*\/]/.test(expr)) {
                return baseExecuteFormula("=" + expr);
            }

            return expr;
        } catch (e) {
            return "#IF_ERR";
        }
    };
</script>
<script>
    /**
     * Updates the formula engine to support direct cell references.
     * Works for both: =A1 and =(A1)
     */
    const originalEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            // Remove the '=' and parentheses, then trim whitespace
            let expr = raw.substring(1).replace(/[()]/g, '').trim().toUpperCase();

            // Check if the remaining expression is exactly one cell ID (e.g., A1, B10, AA5)
            const cellIdPattern = /^[A-Z]+\d+$/;
            
            if (cellIdPattern.test(expr)) {
                // If it's a match, return the display value of that cell
                // We use cellData[expr].display to ensure we get the calculated result
                return cellData[expr] ? cellData[expr].display : "";
            }

            // If it's not a simple reference, pass it back to the main formula logic
            return originalEngine(raw);
        } catch (e) {
            return "#REF!";
        }
    };
</script>
<script>
    /**
     * Adds =RANDOM functionality to Opensheet.
     * Supports: 
     * 1. =RANDOM(A1, B1, C1) - Picks one of the specific cells.
     * 2. =RANDOM(A1:A5) - Picks one cell from the defined range.
     */
    const extensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase();

            // Match RANDOM(args)
            const randomRegex = /RANDOM\(([^)]+)\)/g;

            if (expr.includes("RANDOM")) {
                const result = expr.replace(randomRegex, (match, args) => {
                    let candidates = [];

                    // Check if it's a range (A1:A5) or a list (A1, B1)
                    if (args.includes(':')) {
                        // Use the existing getRangeValues logic but get IDs instead of values
                        const [sId, eId] = args.split(':');
                        const start = parseCellId(sId.trim());
                        const end = parseCellId(eId.trim());
                        
                        if (start && end) {
                            for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++) {
                                for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++) {
                                    candidates.push(getCellId(r, c));
                                }
                            }
                        }
                    } else {
                        // Split by comma for individual cells
                        candidates = args.split(',').map(s => s.trim());
                    }

                    if (candidates.length === 0) return "#REF!";

                    // Pick a random ID from the list
                    const randomId = candidates[Math.floor(Math.random() * candidates.length)];
                    
                    // Return the display value of the chosen cell
                    return cellData[randomId] ? cellData[randomId].display : "";
                });

                // If the result is just the value, return it; otherwise pass to base engine
                return result;
            }

            return extensionEngine(raw);
        } catch (e) {
            return "#RAND_ERR";
        }
    };
</script>
<script>
    /**
     * Adds Date, Year, Day, Month, and DateM functions to Opensheet.
     * All values are pulled from the user's local device.
     */
    const dateExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();
            const now = new Date();

            // =DATE -> DD/MM/YYYY
            if (expr === "DATE") {
                const day = String(now.getDate()).padStart(2, '0');
                const month = String(now.getMonth() + 1).padStart(2, '0');
                return `${day}/${month}/${now.getFullYear()}`;
            }

            // =YEAR -> YYYY
            if (expr === "YEAR") {
                return now.getFullYear();
            }

            // =DAY -> Full weekday name (e.g., Monday)
            if (expr === "DAY") {
                return now.toLocaleDateString(undefined, { weekday: 'long' });
            }

            // =MONTH -> Full month name (e.g., January)
            if (expr === "MONTH") {
                return now.toLocaleDateString(undefined, { month: 'long' });
            }

            // =DATEM -> Just the day of the month (1-31)
            if (expr === "DATEM") {
                return now.getDate();
            }

            // Fallback to previous engine logic (IF, RANDOM, etc.)
            return dateExtensionEngine(raw);
        } catch (e) {
            return "#DATE_ERR";
        }
    };
</script>
<script>
    /**
     * Adds =RN(start:end) functionality to Opensheet.
     * Generates a random integer between the two numbers provided.
     */
    const rnExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();

            // Match RN(number:number)
            const rnRegex = /RN\((\d+):(\d+)\)/;
            const match = expr.match(rnRegex);

            if (match) {
                const start = parseInt(match[1]);
                const end = parseInt(match[2]);

                if (!isNaN(start) && !isNaN(end)) {
                    const min = Math.min(start, end);
                    const max = Math.max(start, end);
                    // Generate random integer between min and max inclusive
                    return Math.floor(Math.random() * (max - min + 1)) + min;
                }
                return "#VAL!";
            }

            // Fallback to previous logic (Date, IF, RANDOM, etc.)
            return rnExtensionEngine(raw);
        } catch (e) {
            return "#RN_ERR";
        }
    };
</script>
<script>
    /**
     * Adds =LIST functionality to Opensheet.
     * Supports:
     * 1. =LIST(A1, B2, C3) -> Displays "Val1, Val2, Val3"
     * 2. =LIST(A1:A5) -> Displays all values in that range separated by commas.
     */
    const listExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();

            if (expr.startsWith("LIST(")) {
                // Extract everything inside the parentheses
                const args = expr.match(/LIST\((.+)\)/)[1];
                let values = [];

                if (args.includes(':')) {
                    // Handle Range: =LIST(A1:A9)
                    const [sId, eId] = args.split(':');
                    const start = parseCellId(sId.trim());
                    const end = parseCellId(eId.trim());

                    if (start && end) {
                        for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++) {
                            for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++) {
                                const val = cellData[getCellId(r, c)]?.display;
                                if (val !== undefined && val !== "") values.push(val);
                            }
                        }
                    }
                } else {
                    // Handle Individual Cells: =LIST(A1, A2, B3)
                    const cellRefs = args.split(',');
                    cellRefs.forEach(ref => {
                        const id = ref.trim();
                        const val = cellData[id]?.display;
                        if (val !== undefined && val !== "") values.push(val);
                    });
                }

                return values.join(', ');
            }

            // Fallback to previous logic (RN, Date, IF, RANDOM, etc.)
            return listExtensionEngine(raw);
        } catch (e) {
            return "#LIST_ERR";
        }
    };
</script>
<script>
    /**
     * Adds Percentage functionality to Opensheet.
     * Supports:
     * 1. (A1)150 -> Takes value of A1 and calculates 150% of it.
     * 2. (10)150 -> Takes number 10 and calculates 150% of it.
     */
    const percentExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();

            // Match pattern: (CellOrNumber)Number
            // Group 1: The value inside () | Group 2: The percentage number
            const percentRegex = /^\(([A-Z0-9.]+)\)(\d+)$/;
            const match = expr.match(percentRegex);

            if (match) {
                const innerPart = match[1];
                const percentAmount = parseFloat(match[2]);
                let baseValue;

                // Check if inner part is a Cell ID or a raw number
                if (/^[A-Z]+\d+$/.test(innerPart)) {
                    baseValue = parseFloat(cellData[innerPart]?.display) || 0;
                } else {
                    baseValue = parseFloat(innerPart) || 0;
                }

                // Calculation: (Base * Percentage) / 100
                const result = (baseValue * percentAmount) / 100;
                return Math.round(result * 100) / 100; // Round to 2 decimal places
            }

            // Fallback to previous logic (LIST, RN, Date, IF, etc.)
            return percentExtensionEngine(raw);
        } catch (e) {
            return "#PERC_ERR";
        }
    };
</script>
<script>
    /**
     * Adds =MOST and =LEAST functionality to Opensheet.
     * Supports both comma-separated lists and colon-separated ranges.
     */
    const statsExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();

            if (expr.startsWith("MOST(") || expr.startsWith("LEAST(")) {
                const isMost = expr.startsWith("MOST(");
                const args = expr.match(/(?:MOST|LEAST)\((.+)\)/)[1];
                let values = [];

                // 1. Collect values from Range or List
                if (args.includes(':')) {
                    const [sId, eId] = args.split(':');
                    const start = parseCellId(sId.trim());
                    const end = parseCellId(eId.trim());
                    if (start && end) {
                        for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++) {
                            for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++) {
                                const val = cellData[getCellId(r, c)]?.display;
                                if (val !== undefined && val !== "") values.push(val);
                            }
                        }
                    }
                } else {
                    const cellRefs = args.split(',');
                    cellRefs.forEach(ref => {
                        const val = cellData[ref.trim()]?.display;
                        if (val !== undefined && val !== "") values.push(val);
                    });
                }

                if (values.length === 0) return "";

                // 2. Count frequencies
                const counts = {};
                values.forEach(v => counts[v] = (counts[v] || 0) + 1);

                // 3. Find the Most or Least repeated
                const sorted = Object.keys(counts).sort((a, b) => {
                    return isMost ? counts[b] - counts[a] : counts[a] - counts[b];
                });

                return sorted[0]; // Returns the top result
            }

            // Fallback to previous logic (Percentage, LIST, RN, Date, IF, etc.)
            return statsExtensionEngine(raw);
        } catch (e) {
            return "#ERR";
        }
    };
</script>
<script>
    /**
     * Adds =CON(range/list, "condition") functionality to Opensheet.
     * Conditions supported: <, >, =, n= (not equal), n< (not smaller than), n> (not bigger than).
     * Returns the most frequent value(s) that meet the condition.
     */
    const conExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();

            if (expr.startsWith("CON(")) {
                // Extract everything inside CON(...)
                const inner = expr.match(/CON\((.+)\)/)[1];
                const parts = inner.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                const conditionStr = parts.pop().trim().replace(/["']/g, ""); // Last arg is condition
                const dataArgs = parts;
                
                let values = [];

                // 1. Collect values from Range or List
                dataArgs.forEach(arg => {
                    const item = arg.trim();
                    if (item.includes(':')) {
                        const [sId, eId] = item.split(':');
                        const start = parseCellId(sId.trim());
                        const end = parseCellId(eId.trim());
                        if (start && end) {
                            for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++) {
                                for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++) {
                                    const val = cellData[getCellId(r, c)]?.display;
                                    if (val !== undefined && val !== "") values.push(val);
                                }
                            }
                        }
                    } else {
                        const val = cellData[item]?.display;
                        if (val !== undefined && val !== "") values.push(val);
                    }
                });

                // 2. Parse Condition and Filter
                const condMatch = conditionStr.match(/^(N[>=<]|[>=<]|N=|=)(.+)$/);
                if (!condMatch) return "#COND_ERR";
                
                const op = condMatch[1];
                const target = parseFloat(condMatch[2]);

                const filtered = values.filter(v => {
                    const num = parseFloat(v);
                    if (isNaN(num)) return false;
                    switch(op) {
                        case '<':  return num < target;
                        case '>':  return num > target;
                        case '=':  return num === target;
                        case 'N=': return num !== target;
                        case 'N<': return num >= target; // Not small (>=)
                        case 'N>': return num <= target; // Not big (<=)
                        default:   return false;
                    }
                });

                if (filtered.length === 0) return "";

                // 3. Count frequencies of filtered values
                const counts = {};
                filtered.forEach(v => counts[v] = (counts[v] || 0) + 1);

                // 4. Find the most frequent frequency
                const maxFreq = Math.max(...Object.values(counts));
                
                // 5. Get all values that share that max frequency
                const mostFrequent = Object.keys(counts).filter(v => counts[v] === maxFreq);

                return mostFrequent.join(', ');
            }

            // Fallback to previous logic (MOST, LEAST, Percentage, etc.)
            return conExtensionEngine(raw);
        } catch (e) {
            return "#CON_ERR";
        }
    };
</script>
<script>
    /**
     * Adds =HOWMP(Total:Current) functionality to Opensheet.
     * Calculates what percentage the second value is of the first.
     * Supports: =HOWMP(A1:B2), =HOWMP(100:B2), =HOWMP(A1:75), =HOWMP(100:75)
     */
    const howmpExtensionEngine = executeFormula;

    executeFormula = function(raw) {
        try {
            let expr = raw.substring(1).toUpperCase().trim();

            // Match pattern: HOWMP(Value1:Value2)
            if (expr.startsWith("HOWMP(")) {
                const inner = expr.match(/HOWMP\((.+)\)/)[1];
                const parts = inner.split(':');
                
                if (parts.length === 2) {
                    let totalVal, currentVal;

                    // Helper to get value from either a Cell ID or a raw number
                    const resolveVal = (input) => {
                        const trimmed = input.trim();
                        if (/^[A-Z]+\d+$/.test(trimmed)) {
                            return parseFloat(cellData[trimmed]?.display) || 0;
                        }
                        return parseFloat(trimmed) || 0;
                    };

                    totalVal = resolveVal(parts[0]);
                    currentVal = resolveVal(parts[1]);

                    if (totalVal === 0) return "0"; // Avoid division by zero

                    // Calculation: (Current / Total) * 100
                    const result = (currentVal / totalVal) * 100;
                    
                    // Return as a string without the % symbol
                    return Math.round(result * 100) / 100; 
                }
                return "#ARGS!";
            }

            // Fallback to previous logic (=!, IFBLANK, CON, etc.)
            return howmpExtensionEngine(raw);
        } catch (e) {
            return "#HOWMP_ERR";
        }
    };
</script>
<style>
    /* Marching Ants / Selection Highlight Style */
    .formula-selecting {
        background: rgba(16, 185, 129, 0.1) !important;
        box-shadow: inset 0 0 0 2px #10b981 !important;
        z-index: 20;
    }
</style>

<style>
    /* Selection Highlight Style */
    .formula-selecting {
        background: rgba(16, 185, 129, 0.1) !important;
        box-shadow: inset 0 0 0 2px #10b981 !important;
        z-index: 20;
    }
    .toggle-active { background-color: #4f46e5 !important; }
    .toggle-dot-active { transform: translateX(20px) !important; }
</style>

<script>
    let autoSelectEnabled = false;
    let isDragging = false;
    let selectionStart = null;
    let activeCellInput = null;
    let activeCellIdForSelection = null;

    function toggleAutoSelect() {
        autoSelectEnabled = !autoSelectEnabled;
        const btn = document.getElementById('auto-select-toggle');
        const dot = document.getElementById('toggle-dot');
        
        if (autoSelectEnabled) {
            btn.classList.add('toggle-active');
            dot.classList.add('toggle-dot-active');
        } else {
            btn.classList.remove('toggle-active');
            dot.classList.remove('toggle-dot-active');
            clearFormulaHighlights();
        }
    }

    function getTargetCellId(el) {
        const td = el.closest('td[id]');
        return td ? td.id : null;
    }

    function clearFormulaHighlights() {
        document.querySelectorAll('.formula-selecting').forEach(el => {
            el.classList.remove('formula-selecting');
        });
    }

    function applyFormulaHighlights(startId, endId) {
        clearFormulaHighlights();
        const start = parseCellId(startId);
        const end = parseCellId(endId);
        if (!start || !end) return;

        for (let r = Math.min(start.r, end.r); r <= Math.max(start.r, end.r); r++) {
            for (let c = Math.min(start.c, end.c); c <= Math.max(start.c, end.c); c++) {
                const id = getCellId(r, c);
                if (id !== activeCellIdForSelection) {
                    document.getElementById(id)?.classList.add('formula-selecting');
                }
            }
        }
    }

    function updateCellText(start, end) {
        if (!activeCellInput) return;
        if (start === end && start === activeCellIdForSelection) return;

        let rangeStr = (start === end) ? start : `${start}:${end}`;
        let currentText = activeCellInput.innerText;
        const lastIndex = Math.max(
            currentText.lastIndexOf('='), 
            currentText.lastIndexOf('('), 
            currentText.lastIndexOf(',')
        );

        const base = currentText.substring(0, lastIndex + 1);
        activeCellInput.innerText = base + rangeStr;

        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(activeCellInput);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
    }

    function onStart(e) {
        if (!autoSelectEnabled) return;

        const target = document.activeElement;
        const isCellEditing = target.tagName === 'TD' && target.innerText.startsWith('=');
        if (!isCellEditing) return;

        const targetId = getTargetCellId(e.target);
        activeCellIdForSelection = target.id;

        if (targetId && targetId !== activeCellIdForSelection) {
            e.preventDefault(); 
            isDragging = true;
            selectionStart = targetId;
            activeCellInput = target;
            applyFormulaHighlights(targetId, targetId);
            updateCellText(targetId, targetId);
        }
    }

    function onMove(e) {
        if (!isDragging || !autoSelectEnabled) return;

        let targetEl;
        if (e.type === 'touchmove') {
            const touch = e.touches[0];
            targetEl = document.elementFromPoint(touch.clientX, touch.clientY);
        } else {
            targetEl = e.target;
        }

        const currentId = getTargetCellId(targetEl);
        if (currentId && selectionStart) {
            applyFormulaHighlights(selectionStart, currentId);
            updateCellText(selectionStart, currentId);
        }
    }

    function onEnd() {
        if (isDragging) {
            isDragging = false;
            if (activeCellInput) activeCellInput.focus();
        }
    }

    const grid = document.getElementById('main-grid');
    grid.addEventListener('mousedown', onStart);
    grid.addEventListener('touchstart', onStart, { passive: false });
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, { passive: false });
    window.addEventListener('mouseup', onEnd);
    window.addEventListener('touchend', onEnd);

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') clearFormulaHighlights();
    });
</script>
<script>
(function () {
    const DATA = {
        1: { n: "SUM", s: "SUM(range)", w: "Adds multiple numbers together. Works across rows, columns, or selected cells. Commonly used for totals and balances.", e: "=SUM(A1:A5)" },
        2: { n: "AVERAGE", s: "AVERAGE(range)", w: "Calculates the middle value. Useful for grades, statistics, and performance tracking.", e: "=AVERAGE(A1:A5)" },
        3: { n: "COUNT", s: "COUNT(range)", w: "Counts cells with numeric values. Text and empty cells are ignored. Helpful for tracking entries.", e: "=COUNT(A1:A5)" },
        4: { n: "MIN", s: "MIN(range)", w: "Finds the smallest number in a group. Great for lowest prices, scores, or measurements.", e: "=MIN(A1:A5)" },
        5: { n: "MAX", s: "MAX(range)", w: "Returns the highest number. Often used for top scores, peaks, or maximum limits.", e: "=MAX(A1:A5)" },
        6: { n: "IF", s: "IF(condition, true, false)", w: "Makes decisions automatically based on a condition. Useful for grading and logical outputs.", e: "=IF(A1>10,\"Pass\",\"Fail\")" },
        7: { n: "RANDOM", s: "RANDOM(range)", w: "Selects a random value from a range. Useful for sampling, games, or testing logic.", e: "=RANDOM(A1:A5)" },
        8: { n: "RN", s: "RN(start:end)", w: "Generates a random number between two defined limits.", e: "=RN(1:100)" },
        9: { n: "LIST", s: "LIST(values)", w: "Combines multiple values into a sequence for grouped displays or previews.", e: "=LIST(A1,A2,A3)" },
        10: { n: "MOST", s: "MOST(range)", w: "Finds the most frequently appearing value (Mode). Great for trend analysis.", e: "=MOST(A1:A5)" },
        11: { n: "LEAST", s: "LEAST(range)", w: "Finds the value that appears the fewest times in a set.", e: "=LEAST(A1:A5)" },
        12: { n: "CON", s: "CON(range, condition)", w: "Filters values based on a logic rule. Only returns matching data. Supporting conditions: <, >, =, N<, N>, N=", e: "=CON(A1:A5,\">10\")" },
        13: { n: "HOWMP", s: "HOWMP(max:value)", w: "Converts a value into a percentage of a maximum limit.", e: "=HOWMP(100:A1)" },
        14: { n: "DATE", s: "DATE", w: "Shows current system date (DD/MM/YYYY). Updates automatically.", e: "=DATE" },
        15: { n: "YEAR", s: "YEAR", w: "Extracts the current year from the system clock.", e: "=YEAR" },
        16: { n: "MONTH", s: "MONTH", w: "Displays the current month name or number.", e: "=MONTH" },
        17: { n: "DAY", s: "DAY", w: "Displays the current day of the month.", e: "=DAY" },
        18: { n: "DATEM", s: "DATEM", w: "Provides the current date of the month only. Useful for date only cases scenarios.", e: "=DATEM" }
    };

    // --- Floating Trigger Button ---
    const btn = document.createElement("div");
    btn.className = "formula-trigger";
    btn.innerHTML = `<span class="material-symbols-outlined" style="font-size: 24px;">function</span>`;
    Object.assign(btn.style, {
        position: 'fixed', bottom: '24px', right: '24px',
        width: '56px', height: '56px', backgroundColor: '#4F46E5',
        color: 'white', borderRadius: '50%', display: 'flex',
        alignItems: 'center', justifyContent: 'center', cursor: 'pointer',
        zIndex: '9999', boxShadow: '0 4px 14px rgba(79, 70, 229, 0.4)',
        transition: 'transform 0.2s ease'
    });
    btn.onmouseover = () => btn.style.transform = 'scale(1.1)';
    btn.onmouseout = () => btn.style.transform = 'scale(1)';
    document.body.appendChild(btn);

    // --- Main Panel ---
    const panel = document.createElement("div");
    Object.assign(panel.style, {
        position: 'fixed', right: '24px', bottom: '90px', width: '380px',
        maxHeight: '80vh', backgroundColor: '#ffffff', borderRadius: '20px',
        boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04)',
        fontFamily: "'Inter', sans-serif", display: 'none', zIndex: '9999',
        overflow: 'hidden', border: '1px solid #f0f0f0', flexDirection: 'column'
    });

    panel.innerHTML = `
        <div style="padding: 20px; background: #F8FAFC; border-bottom: 1px solid #F1F5F9; position: relative;">
            <button id="close-formula" style="position: absolute; right: 15px; top: 15px; border: none; background: #EDF2F7; color: #4A5568; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; display: flex; align-items: center; justify-content: center;">
                <span class="material-symbols-outlined" style="font-size: 18px;">close</span>
            </button>
            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 4px;">
                <div style="background: #4F46E5; color: white; padding: 6px; border-radius: 8px; display: flex;">
                    <span class="material-symbols-outlined" style="font-size: 20px;">menu_book</span>
                </div>
                <div style="font-size: 18px; font-weight: 700; color: #1E293B;">Formula Center</div>
            </div>
            <p style="font-size: 13px; color: #64748B; margin: 0 0 16px 0;">Master the logic of Opensheet</p>
            <div style="position: relative;">
                <span class="material-symbols-outlined" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); color: #94A3B8; font-size: 18px;">search</span>
                <input id="formula-search" placeholder="Search functions..." 
                    style="width: 100%; padding: 10px 10px 10px 36px; border-radius: 12px; border: 1px solid #E2E8F0; font-size: 14px; outline: none; transition: border 0.2s;">
            </div>
        </div>
        <div id="formula-scroll" style="overflow-y: auto; flex: 1; padding: 10px;">
            <div id="formula-list"></div>
            <div id="formula-detail" style="display: none; padding: 10px;"></div>
        </div>
    `;
    document.body.appendChild(panel);

    const searchInput = panel.querySelector("#formula-search");
    const listContainer = panel.querySelector("#formula-list");
    const detailContainer = panel.querySelector("#formula-detail");
    const closeBtn = panel.querySelector("#close-formula");

    // Toggle logic
    const togglePanel = () => {
        const isHidden = panel.style.display === "none";
        panel.style.display = isHidden ? "flex" : "none";
        if (isHidden) {
            renderList("");
            searchInput.focus();
        }
    };

    btn.onclick = togglePanel;
    closeBtn.onclick = () => panel.style.display = "none";

    function renderList(filter) {
        detailContainer.style.display = "none";
        listContainer.style.display = "block";
        listContainer.innerHTML = "";
        
        Object.entries(DATA).forEach(([id, item]) => {
            if (item.n.toLowerCase().includes(filter.toLowerCase()) || id.includes(filter)) {
                const itemEl = document.createElement("div");
                Object.assign(itemEl.style, {
                    padding: '12px 16px', borderRadius: '12px', cursor: 'pointer',
                    display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                    marginBottom: '4px', transition: 'background 0.2s'
                });
                itemEl.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 12px; font-weight: 600; color: #94A3B8; width: 20px;">${id}</span>
                        <span style="font-weight: 600; color: #334155;">${item.n}</span>
                    </div>
                    <span class="material-symbols-outlined" style="color: #CBD5E1; font-size: 18px;">chevron_right</span>
                `;
                itemEl.onmouseover = () => itemEl.style.backgroundColor = '#F1F5F9';
                itemEl.onmouseout = () => itemEl.style.backgroundColor = 'transparent';
                itemEl.onclick = () => showDetail(id);
                listContainer.appendChild(itemEl);
            }
        });
    }

    function showDetail(id) {
        const d = DATA[id];
        listContainer.style.display = "none";
        detailContainer.style.display = "block";
        detailContainer.innerHTML = `
            <button id="back-to-list" style="display: flex; align-items: center; gap: 4px; border: none; background: none; color: #4F46E5; font-size: 13px; font-weight: 600; cursor: pointer; margin-bottom: 16px; padding: 0;">
                <span class="material-symbols-outlined" style="font-size: 16px;">arrow_back</span> Back to list
            </button>
            <div style="font-size: 22px; font-weight: 800; color: #1E293B; margin-bottom: 4px;">${d.n}</div>
            <div style="font-family: monospace; background: #EEF2FF; color: #4F46E5; padding: 8px 12px; border-radius: 8px; font-size: 14px; margin-bottom: 20px;">${d.s}</div>
            
            <div style="margin-bottom: 20px;">
                <div style="font-size: 12px; font-weight: 700; color: #94A3B8; text-transform: uppercase; margin-bottom: 6px;">Description</div>
                <div style="font-size: 14px; color: #475569; line-height: 1.6;">${d.w}</div>
            </div>

            <div>
                <div style="font-size: 12px; font-weight: 700; color: #94A3B8; text-transform: uppercase; margin-bottom: 6px;">Example</div>
                <div style="background: #1E293B; color: #F8FAFC; padding: 16px; border-radius: 12px; position: relative;">
                    <code id="example-code" style="font-family: monospace; font-size: 14px;">${d.e}</code>
                    <button id="copy-btn" style="position: absolute; right: 8px; top: 8px; background: rgba(255,255,255,0.1); border: none; color: white; border-radius: 6px; padding: 4px; cursor: pointer;">
                        <span class="material-symbols-outlined" style="font-size: 16px;">content_copy</span>
                    </button>
                </div>
            </div>
        `;

        detailContainer.querySelector("#back-to-list").onclick = () => renderList(searchInput.value);
        
        detailContainer.querySelector("#copy-btn").onclick = function() {
            navigator.clipboard.writeText(d.e);
            this.innerHTML = `<span class="material-symbols-outlined" style="font-size: 16px; color: #10B981;">check</span>`;
            setTimeout(() => this.innerHTML = `<span class="material-symbols-outlined" style="font-size: 16px;">content_copy</span>`, 2000);
        };
    }

    searchInput.oninput = e => renderList(e.target.value);
    
    // Initial Render
    renderList("");
})();
</script>
</body>
</html>

