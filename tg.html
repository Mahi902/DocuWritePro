<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cube Parkour Adventure</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Fredoka One', cursive;
            touch-action: none; /* Prevent browser zooming/scrolling */
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .interactive {
            pointer-events: auto;
        }
        .btn {
            background: linear-gradient(to bottom, #4ade80, #22c55e);
            border: 4px solid #14532d;
            border-radius: 12px;
            color: white;
            text-shadow: 2px 2px 0px #14532d;
            transition: transform 0.1s, filter 0.1s;
            cursor: pointer;
            font-family: 'Fredoka One', cursive;
        }
        .btn:active {
            transform: scale(0.95);
            filter: brightness(0.9);
        }
        .btn-red {
            background: linear-gradient(to bottom, #f87171, #ef4444);
            border-color: #7f1d1d;
            text-shadow: 2px 2px 0px #7f1d1d;
        }
        .btn-blue {
            background: linear-gradient(to bottom, #60a5fa, #3b82f6);
            border-color: #1e3a8a;
            text-shadow: 2px 2px 0px #1e3a8a;
        }
        .panel {
            background: rgba(30, 41, 59, 0.95);
            border: 4px solid #475569;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        /* HUD Animations */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .buff-icon {
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .buff-blinking {
            animation: blink 0.5s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        @keyframes popIn {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }
        
        /* Shop Item Styles */
        .shop-item.locked {
            filter: grayscale(1);
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="uiLayer" class="ui-layer p-4">
        
        <!-- Top Bar (Always Visible In-Game) -->
        <div id="hud" class="hidden w-full flex justify-between items-start pointer-events-none">
            <div class="flex flex-col gap-2">
                <!-- Hearts -->
                <div id="heartContainer" class="flex gap-1 text-3xl filter drop-shadow-md">
                    <!-- Injected via JS -->
                </div>
                <!-- Score -->
                <div class="text-white text-2xl drop-shadow-md">
                    Score: <span id="scoreDisplay">0</span>
                </div>
            </div>

            <!-- Active Effects -->
            <div id="effectsContainer" class="flex flex-col gap-2 items-end">
                <!-- Injected via JS -->
            </div>
            
            <!-- Pause Button -->
            <div class="absolute top-4 right-1/2 transform translate-x-1/2 interactive">
                <button id="pauseBtn" class="btn bg-gray-700 border-gray-900 w-10 h-10 flex items-center justify-center rounded-full text-xl">
                    ||
                </button>
            </div>
        </div>

        <!-- Home Screen -->
        <div id="homeScreen" class="absolute inset-0 flex flex-col items-center justify-center interactive bg-slate-900/80 backdrop-blur-sm transition-opacity duration-300">
            <h1 class="text-6xl md:text-8xl text-transparent bg-clip-text bg-gradient-to-b from-yellow-300 to-orange-500 mb-8 drop-shadow-lg" style="font-family: 'Press Start 2P'; text-shadow: 4px 4px 0 #000;">
                CUBE<br>PARKOUR
            </h1>
            
            <div class="flex flex-col gap-4 items-center">
                <button id="playBtn" class="btn text-3xl px-12 py-4 shadow-lg hover:scale-105">PLAY</button>
                <div class="flex gap-4">
                    <button id="shopBtn" class="btn btn-blue text-xl px-6 py-3">SHOP</button>
                    <button id="settingsBtn" class="btn bg-gray-600 border-gray-800 text-xl px-6 py-3">SETTINGS</button>
                </div>
            </div>

            <!-- Currency Display Home -->
            <div class="absolute top-6 left-6 flex items-center gap-2 bg-slate-800 p-3 rounded-lg border-2 border-slate-600">
                <div class="w-6 h-6 bg-yellow-400 rounded-full border-2 border-yellow-600 shadow-[inset_-2px_-2px_0_rgba(0,0,0,0.2)]"></div>
                <span id="homeCoins" class="text-yellow-400 text-xl">0</span>
            </div>
        </div>

        <!-- Shop Screen -->
        <div id="shopScreen" class="hidden absolute inset-0 flex items-center justify-center interactive bg-black/90 backdrop-blur-md">
            <div class="panel w-full max-w-4xl h-5/6 p-6 flex flex-col relative overflow-hidden">
                <button id="closeShopBtn" class="absolute top-4 right-4 btn btn-red w-10 h-10 flex items-center justify-center">X</button>
                <h2 class="text-4xl text-white text-center mb-2">Item Shop</h2>
                <div class="text-center text-yellow-400 text-xl mb-6">Coins: <span id="shopCoins">0</span></div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 overflow-y-auto pr-2 custom-scrollbar flex-1">
                    
                    <!-- Speed Upgrades -->
                    <div class="bg-slate-700/50 p-4 rounded-xl border-2 border-slate-600 flex flex-col items-center">
                        <div class="text-3xl mb-2">‚ö°</div>
                        <h3 class="text-white text-xl mb-1">Max Speed</h3>
                        <p class="text-slate-300 text-xs mb-4 text-center">Run faster across the void.</p>
                        <div id="speedUpgradeContainer" class="w-full">
                            <!-- JS Injects Button -->
                        </div>
                        <div class="mt-2 w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                            <div id="speedBar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
                        </div>
                    </div>

                    <!-- Jump Upgrades -->
                    <div class="bg-slate-700/50 p-4 rounded-xl border-2 border-slate-600 flex flex-col items-center">
                        <div class="text-3xl mb-2">üöÄ</div>
                        <h3 class="text-white text-xl mb-1">Jump Force</h3>
                        <p class="text-slate-300 text-xs mb-4 text-center">Leap higher and further.</p>
                        <div id="jumpUpgradeContainer" class="w-full">
                            <!-- JS Injects Button -->
                        </div>
                        <div class="mt-2 w-full bg-slate-800 h-2 rounded-full overflow-hidden">
                            <div id="jumpBar" class="h-full bg-green-500 w-0 transition-all duration-300"></div>
                        </div>
                    </div>

                    <!-- Health Upgrades -->
                    <div class="bg-slate-700/50 p-4 rounded-xl border-2 border-slate-600 flex flex-col items-center">
                        <div class="text-3xl mb-2">‚ù§Ô∏è</div>
                        <h3 class="text-white text-xl mb-1">Extra Lives</h3>
                        <p class="text-slate-300 text-xs mb-4 text-center">Start with more hearts.</p>
                        <div id="healthUpgradeContainer" class="w-full">
                            <!-- JS Injects Button -->
                        </div>
                        <div class="mt-2 text-white text-sm">
                            Current: <span id="maxHealthDisplay">3</span> Hearts
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settingsScreen" class="hidden absolute inset-0 flex items-center justify-center interactive bg-black/90 backdrop-blur-md">
            <div class="panel p-8 w-96 flex flex-col gap-6 text-center">
                <h2 class="text-3xl text-white">Settings</h2>
                
                <div class="flex justify-between items-center text-white text-xl">
                    <span>Sounds</span>
                    <button id="toggleSound" class="btn w-20 py-2">ON</button>
                </div>

                <div class="flex justify-between items-center text-white text-xl">
                    <span>Show Effects</span>
                    <button id="toggleEffects" class="btn w-20 py-2">ON</button>
                </div>
                
                <button id="closeSettingsBtn" class="btn btn-blue mt-4">Close</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="hidden absolute inset-0 flex flex-col items-center justify-center interactive bg-black/85 backdrop-blur-sm z-50">
            <h1 class="text-6xl text-red-500 mb-2 font-bold drop-shadow-lg">GAME OVER</h1>
            <div class="text-white text-2xl mb-8">Score: <span id="finalScore">0</span></div>
            <div class="text-yellow-400 text-3xl mb-12 animate-bounce">
                +<span id="earnedCoins">0</span> Coins
            </div>
            <div class="flex gap-6">
                <button id="restartBtn" class="btn text-2xl px-8 py-4">RESTART</button>
                <button id="homeBtn" class="btn btn-blue text-2xl px-8 py-4">HOME</button>
            </div>
        </div>

    </div>

<script>
/**
 * AUDIO ENGINE
 * Synthesizes sounds in real-time. No external assets.
 */
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
        this.bgmOscillators = [];
        this.bgmPlaying = false;
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        this.masterGain.gain.value = 0.3; // Global volume
    }

    playTone(freq, type, duration, vol = 1, slideTo = null) {
        if (!this.enabled || this.ctx.state === 'suspended') {
            if(this.ctx.state === 'suspended') this.ctx.resume();
            if(!this.enabled) return;
        }

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slideTo) {
            osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
        }

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playJump() {
        // Slide up frequency for jump
        this.playTone(150, 'square', 0.2, 0.3, 300);
    }

    playLand() {
        // Noise-like thud
        this.playTone(100, 'sawtooth', 0.1, 0.4, 50);
    }

    playCoin() {
        // High pitched "ding"
        this.playTone(1200, 'sine', 0.1, 0.3);
        setTimeout(() => this.playTone(1800, 'sine', 0.2, 0.3), 50);
    }

    playGem(rarity) {
        // Arpeggio
        const base = rarity === 'legendary' ? 220 : 440;
        const wave = rarity === 'legendary' ? 'sawtooth' : 'sine';
        this.playTone(base, wave, 0.1, 0.3);
        setTimeout(() => this.playTone(base * 1.5, wave, 0.1, 0.3), 80);
        setTimeout(() => this.playTone(base * 2, wave, 0.2, 0.3), 160);
    }

    playPowerupStart() {
        this.playTone(200, 'square', 0.5, 0.2, 600);
    }

    playFall() {
        this.playTone(300, 'sawtooth', 0.8, 0.3, 50);
    }

    playClick() {
        this.playTone(400, 'triangle', 0.05, 0.2);
    }

    startBGM() {
        if (!this.enabled || this.bgmPlaying) return;
        this.bgmPlaying = true;
        this.scheduleNote();
    }

    stopBGM() {
        this.bgmPlaying = false;
        // Simple flag stop, complex scheduler clearing omitted for brevity
    }

    scheduleNote() {
        if (!this.bgmPlaying) return;
        // Simple procedural beat
        const time = this.ctx.currentTime;
        const noteLength = 0.2;
        // Bass
        const bassOsc = this.ctx.createOscillator();
        const bassGain = this.ctx.createGain();
        bassOsc.connect(bassGain);
        bassGain.connect(this.masterGain);
        bassOsc.type = 'triangle';
        // Random pentatonic melody C Minor
        const notes = [130.81, 155.56, 174.61, 196.00, 233.08]; 
        const note = notes[Math.floor(Math.random() * notes.length)];
        
        bassOsc.frequency.setValueAtTime(note, time);
        bassGain.gain.setValueAtTime(0.1, time);
        bassGain.gain.exponentialRampToValueAtTime(0.01, time + noteLength);
        
        bassOsc.start(time);
        bassOsc.stop(time + noteLength);

        setTimeout(() => this.scheduleNote(), 250); // 4 notes per second approx
    }
}

/**
 * GAME ENGINE & DATA
 */
const STORAGE_KEY = 'cube_parkour_save_v1';
const SOUND = new SoundManager();

// Game Constants
const GRAVITY = 0.6;
const FRICTION = 0.8;
const BASE_SPEED = 5;
const BASE_JUMP = 12;

// Data Models
const defaultSaveData = {
    coins: 0,
    upgrades: {
        speed: 0,
        jump: 0,
        health: 0 // 0 = 3 hearts, 1 = 4, 2 = 5
    },
    settings: {
        sound: true,
        showEffects: true
    }
};

const shopConfig = {
    speed: [
        { val: 1.1, cost: 6 }, { val: 1.2, cost: 7 }, { val: 1.3, cost: 8 },
        { val: 1.4, cost: 9 }, { val: 1.5, cost: 10 }, { val: 1.6, cost: 12 },
        { val: 1.8, cost: 30 }, { val: 2.0, cost: 50 }
    ],
    jump: [
        { val: 1.2, cost: 5 }, { val: 1.4, cost: 10 }, { val: 1.6, cost: 15 },
        { val: 1.8, cost: 20 }, { val: 2.0, cost: 30 }, { val: 3.0, cost: 60 }
    ],
    health: [
        { val: 1, cost: 100 }, { val: 2, cost: 100 }
    ]
};

const gemTypes = {
    red: { color: '#ef4444', icon: '‚ù§Ô∏è', name: 'Extra Heart', rarity: 0.15, duration: 0 },
    green: { color: '#22c55e', icon: '‚ö°', name: 'Speed Boost', rarity: 0.4, duration: 10000 },
    yellow: { color: '#eab308', icon: 'üöÄ', name: 'Jump Boost', rarity: 0.3, duration: 10000 },
    orange: { color: '#f97316', icon: 'ü™∂', name: 'Feather Fall', rarity: 0.1, duration: 8000 },
    black: { color: '#000000', border: '#fff', icon: 'üíé', name: 'LEGENDARY FLIGHT', rarity: 0.05, duration: 5000 }
};

// Global State
let canvas, ctx;
let lastTime = 0;
let saveData = JSON.parse(JSON.stringify(defaultSaveData));
let gameState = 'HOME'; // HOME, PLAYING, PAUSED, GAMEOVER
let scoreTimer = 0;
let score = 0;

// Game Objects
let player = {
    x: 0, y: 0, w: 30, h: 30,
    vx: 0, vy: 0,
    color: '#3b82f6',
    rotation: 0,
    grounded: false,
    squashX: 1, squashY: 1,
    hearts: 3,
    maxHearts: 3,
    activeEffects: [],
    invincible: 0,
    facingRight: true
};

let camera = { x: 0, y: 0 };
let platforms = [];
let gems = [];
let particles = [];
let backgroundStars = [];

function loadSave() {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
        const parsed = JSON.parse(raw);
        saveData = { ...defaultSaveData, ...parsed, upgrades: { ...defaultSaveData.upgrades, ...parsed.upgrades }, settings: { ...defaultSaveData.settings, ...parsed.settings } };
    }
    SOUND.enabled = saveData.settings.sound;
    updateUI();
}

function saveGame() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
    updateUI();
}

/**
 * INITIALIZATION
 */
function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // UI Event Listeners
    document.getElementById('playBtn').onclick = startGame;
    document.getElementById('restartBtn').onclick = startGame;
    document.getElementById('homeBtn').onclick = goHome;
    document.getElementById('shopBtn').onclick = () => showScreen('shopScreen');
    document.getElementById('closeShopBtn').onclick = () => showScreen('homeScreen');
    document.getElementById('settingsBtn').onclick = () => showScreen('settingsScreen');
    document.getElementById('closeSettingsBtn').onclick = () => showScreen('homeScreen');
    document.getElementById('toggleSound').onclick = toggleSound;
    document.getElementById('toggleEffects').onclick = toggleEffects;
    document.getElementById('pauseBtn').onclick = togglePause;
    
    // Shop Listeners
    setupShopListeners();

    // Input Listeners
    window.addEventListener('keydown', handleKey);
    window.addEventListener('keyup', handleKeyUp);
    
    // Touch Inputs
    canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
    canvas.addEventListener('touchend', handleTouchEnd);
    canvas.addEventListener('touchmove', (e) => e.preventDefault(), {passive: false});

    resize();
    window.addEventListener('resize', resize);
    
    // Generate Stars
    for(let i=0; i<100; i++) {
        backgroundStars.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 2 + 1,
            speed: Math.random() * 0.5 + 0.1
        });
    }

    loadSave();
    showScreen('homeScreen');
    requestAnimationFrame(loop);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function setupShopListeners() {
    // Helper to render buttons
    const renderShop = () => {
        document.getElementById('shopCoins').innerText = saveData.coins;
        
        // Speed
        const speedLvl = saveData.upgrades.speed;
        const nextSpeed = shopConfig.speed[speedLvl];
        const speedContainer = document.getElementById('speedUpgradeContainer');
        const speedBar = document.getElementById('speedBar');
        speedBar.style.width = `${(speedLvl / shopConfig.speed.length) * 100}%`;

        if (!nextSpeed) {
            speedContainer.innerHTML = `<button class="btn w-full bg-gray-500 border-gray-700 cursor-default">MAXED OUT</button>`;
        } else {
            speedContainer.innerHTML = `<button onclick="buyUpgrade('speed')" class="btn w-full ${saveData.coins >= nextSpeed.cost ? 'btn-blue' : 'bg-gray-500 border-gray-700'}">Speed ${nextSpeed.val}x <br>(${nextSpeed.cost} Coins)</button>`;
        }

        // Jump
        const jumpLvl = saveData.upgrades.jump;
        const nextJump = shopConfig.jump[jumpLvl];
        const jumpContainer = document.getElementById('jumpUpgradeContainer');
        const jumpBar = document.getElementById('jumpBar');
        jumpBar.style.width = `${(jumpLvl / shopConfig.jump.length) * 100}%`;

        if (!nextJump) {
            jumpContainer.innerHTML = `<button class="btn w-full bg-gray-500 border-gray-700 cursor-default">MAXED OUT</button>`;
        } else {
            jumpContainer.innerHTML = `<button onclick="buyUpgrade('jump')" class="btn w-full ${saveData.coins >= nextJump.cost ? 'btn-blue' : 'bg-gray-500 border-gray-700'}">Jump ${nextJump.val}x <br>(${nextJump.cost} Coins)</button>`;
        }

        // Health
        const healthLvl = saveData.upgrades.health;
        const nextHealth = shopConfig.health[healthLvl];
        const healthContainer = document.getElementById('healthUpgradeContainer');
        document.getElementById('maxHealthDisplay').innerText = 3 + healthLvl;

        if (!nextHealth) {
            healthContainer.innerHTML = `<button class="btn w-full bg-gray-500 border-gray-700 cursor-default">MAXED OUT</button>`;
        } else {
            healthContainer.innerHTML = `<button onclick="buyUpgrade('health')" class="btn w-full ${saveData.coins >= nextHealth.cost ? 'btn-blue' : 'bg-gray-500 border-gray-700'}">+1 Heart <br>(${nextHealth.cost} Coins)</button>`;
        }
    };

    window.buyUpgrade = (type) => {
        const lvl = saveData.upgrades[type];
        const cfg = shopConfig[type][lvl];
        if (cfg && saveData.coins >= cfg.cost) {
            saveData.coins -= cfg.cost;
            saveData.upgrades[type]++;
            SOUND.playCoin();
            saveGame();
            renderShop();
            updateUI(); // Update home coins
        } else {
            SOUND.playTone(100, 'sawtooth', 0.2); // Error buzz
        }
    };
    
    // Expose render function so it updates when shop opens
    window.renderShop = renderShop;
}

/**
 * GAME LOGIC
 */
function resetGame() {
    player.x = 100;
    player.y = 300;
    player.vx = 0;
    player.vy = 0;
    player.hearts = 3 + saveData.upgrades.health;
    player.maxHearts = 3 + saveData.upgrades.health;
    player.activeEffects = [];
    player.squashX = 1;
    player.squashY = 1;
    player.rotation = 0;
    
    score = 0;
    scoreTimer = 0;
    
    platforms = [
        { x: 0, y: 400, w: 500, h: 50, type: 'normal' }
    ];
    gems = [];
    particles = [];
    camera.x = 0;
    
    generatePlatforms(1000); // Generate initial chunk
}

function startGame() {
    resetGame();
    gameState = 'PLAYING';
    SOUND.startBGM();
    showScreen('hud');
    updateHUD();
}

function goHome() {
    gameState = 'HOME';
    SOUND.stopBGM();
    showScreen('homeScreen');
}

function togglePause() {
    if (gameState === 'PLAYING') {
        gameState = 'PAUSED';
        document.getElementById('pauseBtn').innerText = '‚ñ∂';
    } else if (gameState === 'PAUSED') {
        gameState = 'PLAYING';
        document.getElementById('pauseBtn').innerText = '||';
    }
    SOUND.playClick();
}

function toggleSound() {
    saveData.settings.sound = !saveData.settings.sound;
    SOUND.enabled = saveData.settings.sound;
    document.getElementById('toggleSound').innerText = SOUND.enabled ? 'ON' : 'OFF';
    if(SOUND.enabled) {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    }
    saveGame();
}

function toggleEffects() {
    saveData.settings.showEffects = !saveData.settings.showEffects;
    document.getElementById('toggleEffects').innerText = saveData.settings.showEffects ? 'ON' : 'OFF';
    saveGame();
}

// UI State Management
function showScreen(id) {
    document.getElementById('homeScreen').classList.add('hidden');
    document.getElementById('shopScreen').classList.add('hidden');
    document.getElementById('settingsScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    document.getElementById('hud').classList.add('hidden');
    
    const screen = document.getElementById(id);
    if (screen) screen.classList.remove('hidden');

    if (id === 'shopScreen') window.renderShop();
    updateUI();
}

function updateUI() {
    document.getElementById('homeCoins').innerText = saveData.coins;
    document.getElementById('toggleSound').innerText = saveData.settings.sound ? 'ON' : 'OFF';
    document.getElementById('toggleEffects').innerText = saveData.settings.showEffects ? 'ON' : 'OFF';
}

function updateHUD() {
    // Hearts
    const heartContainer = document.getElementById('heartContainer');
    heartContainer.innerHTML = '';
    for (let i = 0; i < player.hearts; i++) {
        heartContainer.innerHTML += '<span class="text-red-500">‚ô•</span>';
    }
    for (let i = 0; i < (player.maxHearts - player.hearts); i++) {
        heartContainer.innerHTML += '<span class="text-gray-500">‚ô•</span>';
    }

    // Score
    document.getElementById('scoreDisplay').innerText = score;

    // Effects
    const effectsContainer = document.getElementById('effectsContainer');
    effectsContainer.innerHTML = '';
    
    player.activeEffects.forEach(eff => {
        const timeLeft = eff.endTime - Date.now();
        const isBlinking = timeLeft < 4000;
        const blinkClass = isBlinking ? 'buff-blinking' : '';
        const nameDisplay = saveData.settings.showEffects ? `<span class="text-white text-sm shadow-black drop-shadow-md ml-2">${eff.def.name}</span>` : '';
        
        const div = document.createElement('div');
        div.className = `flex items-center bg-black/40 p-1 rounded-lg buff-icon ${blinkClass}`;
        div.innerHTML = `
            <div class="w-8 h-8 rounded flex items-center justify-center text-xl border-2" 
                 style="background-color: ${eff.def.color}44; border-color: ${eff.def.color}">
                 ${eff.def.icon}
            </div>
            ${nameDisplay}
        `;
        effectsContainer.appendChild(div);
    });
}

/**
 * INPUT HANDLING
 */
const keys = {};
function handleKey(e) { keys[e.code] = true; }
function handleKeyUp(e) { keys[e.code] = false; }

let touchControls = { left: false, right: false, jump: false };
function handleTouchStart(e) {
    for (let i=0; i < e.touches.length; i++) {
        const t = e.touches[i];
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        if (t.clientY > h * 0.2) { // Ignore top area (UI)
            if (t.clientX < w * 0.4) touchControls.left = true;
            else if (t.clientX > w * 0.6) touchControls.right = true;
            else touchControls.jump = true; // Middle or tap
        }
    }
}
function handleTouchEnd(e) {
    // Naive reset, better to track touch IDs but simple works for this scope
    if (e.touches.length === 0) {
        touchControls.left = false;
        touchControls.right = false;
        touchControls.jump = false;
    }
}

/**
 * PHYSICS & UPDATE
 */
function update(dt) {
    if (gameState !== 'PLAYING') return;

    // 1. Time & Score
    scoreTimer += dt;
    if (scoreTimer >= 2000) {
        score++;
        scoreTimer -= 2000;
        updateHUD();
    }

    // 2. Platform Generation
    const lastPlat = platforms[platforms.length - 1];
    if (lastPlat.x < camera.x + canvas.width + 200) {
        generatePlatforms(1);
    }
    // Cleanup old platforms
    if (platforms[0].x + platforms[0].w < camera.x - 100) {
        platforms.shift();
    }

    // 3. Modifiers (Base Stats + Upgrades + Effects)
    let speedMult = 1;
    // Apply Upgrade
    if (shopConfig.speed[saveData.upgrades.speed]) {
        speedMult = shopConfig.speed[saveData.upgrades.speed].val;
    } else { // Maxed case
        speedMult = 2.0; 
    }
    
    let jumpMult = 1;
    if (shopConfig.jump[saveData.upgrades.jump]) {
        jumpMult = shopConfig.jump[saveData.upgrades.jump].val;
    } else {
        jumpMult = 3.0;
    }

    let gravityMult = 1;
    let flightMode = false;

    // Process Active Effects
    const now = Date.now();
    player.activeEffects = player.activeEffects.filter(e => e.endTime > now);
    player.activeEffects.forEach(e => {
        if (e.type === 'green') speedMult += 0.5;
        if (e.type === 'yellow') jumpMult += 0.5;
        if (e.type === 'orange') gravityMult = 0.3; // Slow fall
        if (e.type === 'black') {
            flightMode = true;
            gravityMult = 0.1;
            speedMult += 2.0; // Glide quickly
        }
    });
    
    // UI Update for blinking effects
    updateHUD();

    // 4. Movement Physics
    // Horizontal
    let moveDir = 0;
    if (keys['ArrowRight'] || keys['KeyD'] || touchControls.right) moveDir = 1;
    if (keys['ArrowLeft'] || keys['KeyA'] || touchControls.left) moveDir = -1;
    
    // Flight Mode Override
    if (flightMode) moveDir = 1; // Forced forward

    player.vx += moveDir * 1.5;
    player.vx *= FRICTION;
    
    const currentMaxSpeed = BASE_SPEED * speedMult;
    if (player.vx > currentMaxSpeed) player.vx = currentMaxSpeed;
    if (player.vx < -currentMaxSpeed) player.vx = -currentMaxSpeed;

    player.x += player.vx;
    if (moveDir !== 0) player.facingRight = moveDir > 0;

    // Vertical
    player.vy += GRAVITY * gravityMult;
    player.y += player.vy;

    // Jump
    const jumpReq = keys['ArrowUp'] || keys['Space'] || keys['KeyW'] || touchControls.jump;
    if (jumpReq && player.grounded) {
        let force = BASE_JUMP * jumpMult;
        
        // Jump Pad Check (is cur platform boost?)
        const currentPlat = platforms.find(p => 
            player.x + player.w > p.x && player.x < p.x + p.w &&
            player.y + player.h >= p.y && player.y + player.h <= p.y + 20
        );

        if (currentPlat && currentPlat.type === 'boost') {
            force *= 1.5;
            createParticles(player.x + player.w/2, player.y + player.h, '#eab308', 10);
            SOUND.playPowerupStart();
        }

        player.vy = -force;
        player.grounded = false;
        player.squashX = 0.8;
        player.squashY = 1.2;
        SOUND.playJump();
    }
    
    // Reset Touch Jump so it doesn't auto-fire
    touchControls.jump = false; 

    // 5. Collision & Landing
    player.grounded = false;
    // Simple AABB vs Platforms (Only check falling down)
    if (player.vy >= 0) {
        for (let p of platforms) {
            if (
                player.x + player.w > p.x &&
                player.x < p.x + p.w &&
                player.y + player.h >= p.y &&
                player.y + player.h <= p.y + p.h + player.vy // Tunneling fix
            ) {
                // Landed
                player.y = p.y - player.h;
                player.vy = 0;
                if (!player.grounded) { // First frame of landing
                    player.squashX = 1.3;
                    player.squashY = 0.7;
                    player.rotation = 0; // Snap rotation
                    createParticles(player.x + player.w/2, player.y + player.h, '#fff', 5);
                    SOUND.playLand();
                }
                player.grounded = true;
            }
        }
    }

    // 6. Void Logic
    if (player.y > canvas.height + 100) {
        handleDeath();
    }

    // 7. Gem Collection
    gems = gems.filter(g => {
        // AABB
        if (
            player.x < g.x + 30 &&
            player.x + player.w > g.x &&
            player.y < g.y + 30 &&
            player.y + player.h > g.y
        ) {
            collectGem(g);
            return false;
        }
        return true;
    });

    // 8. Animations
    // Squash recover
    player.squashX += (1 - player.squashX) * 0.1;
    player.squashY += (1 - player.squashY) * 0.1;
    
    // Rotation in air
    if (!player.grounded) {
        player.rotation += (player.vx * 0.05) + (player.facingRight ? 0.05 : -0.05);
    }

    // 9. Camera Follow
    const targetCamX = player.x - canvas.width * 0.3;
    camera.x += (targetCamX - camera.x) * 0.1;
    
    // Particles update
    updateParticles();
}

function generatePlatforms(distAhead) {
    let lastPlat = platforms[platforms.length-1];
    let currentX = lastPlat.x + lastPlat.w;
    
    // Ensure we generate enough to cover distance
    while(currentX < lastPlat.x + distAhead) {
        const gap = 50 + Math.random() * 150; // Random gap
        const w = 100 + Math.random() * 200;
        // Y changes: limit verticality so it's playable
        let y = lastPlat.y + (Math.random() * 200 - 100);
        // Clamp Y
        if (y < 200) y = 200;
        if (y > canvas.height - 100) y = canvas.height - 100;

        const type = Math.random() < 0.1 ? 'boost' : 'normal';

        platforms.push({ x: currentX + gap, y: y, w: w, h: 40, type: type });
        
        // Gem Generation Chance
        if (Math.random() < 0.3) {
            spawnGem(currentX + gap + w/2, y - 60);
        }

        currentX += gap + w;
        lastPlat = platforms[platforms.length-1];
    }
}

function spawnGem(x, y) {
    const roll = Math.random();
    let type = 'green'; // default
    if (roll < 0.05) type = 'black';
    else if (roll < 0.15) type = 'orange'; // rare
    else if (roll < 0.30) type = 'red'; // health
    else if (roll < 0.60) type = 'yellow'; // jump
    
    // Prevent hearts if full
    if (type === 'red' && player.hearts >= player.maxHearts) type = 'green';

    gems.push({ x, y, type, floatOffset: Math.random() * Math.PI * 2 });
}

function collectGem(gem) {
    const def = gemTypes[gem.type];
    createParticles(gem.x + 15, gem.y + 15, def.color, 15);
    SOUND.playGem(gem.type);

    if (gem.type === 'red') {
        if (player.hearts < player.maxHearts) {
            player.hearts++;
            updateHUD();
        }
    } else {
        // Add Effect logic
        if (gem.type === 'black') {
            // Thirsts into sky
            player.vy = -25;
            player.grounded = false;
        }

        // Add or refresh effect
        const existing = player.activeEffects.find(e => e.type === gem.type);
        if (existing) {
            existing.endTime = Date.now() + def.duration;
        } else {
            player.activeEffects.push({
                type: gem.type,
                endTime: Date.now() + def.duration,
                def: def
            });
        }
    }
    updateHUD();
}

function handleDeath() {
    SOUND.playFall();
    player.hearts--;
    
    if (player.hearts <= 0) {
        gameOver();
    } else {
        // Respawn
        const safePlat = platforms.find(p => p.x > camera.x + 100) || platforms[platforms.length-1];
        player.x = safePlat.x + 20;
        player.y = safePlat.y - 100;
        player.vx = 0;
        player.vy = 0;
        player.activeEffects = []; // Clear effects on fall? Rules say "Falling makes one heart gone". Usually buffs stay. Let's clear flight though.
        player.activeEffects = player.activeEffects.filter(e => e.type !== 'black'); 
        updateHUD();
    }
}

function gameOver() {
    gameState = 'GAMEOVER';
    SOUND.stopBGM();
    SOUND.playTone(100, 'sawtooth', 0.5, 0.5, 50); // Lose sound
    
    const earnedCoins = Math.round(score / 10);
    saveData.coins += earnedCoins;
    saveGame();

    document.getElementById('finalScore').innerText = score;
    document.getElementById('earnedCoins').innerText = earnedCoins;
    showScreen('gameOverScreen');
}

/**
 * RENDERING
 */
function draw() {
    // Clear
    ctx.fillStyle = '#111827'; // Dark sky
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Stars
    ctx.fillStyle = '#fff';
    backgroundStars.forEach(star => {
        // Parallax
        let x = (star.x - camera.x * star.speed) % canvas.width;
        if (x < 0) x += canvas.width;
        ctx.beginPath();
        ctx.arc(x, star.y, star.size, 0, Math.PI*2);
        ctx.fill();
    });

    ctx.save();
    ctx.translate(-camera.x, 0);

    // Platforms
    platforms.forEach(p => {
        ctx.fillStyle = p.type === 'boost' ? '#eab308' : '#475569';
        // Neon glow
        ctx.shadowColor = p.type === 'boost' ? '#facc15' : '#000';
        ctx.shadowBlur = p.type === 'boost' ? 15 : 0;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // Top highlight
        ctx.fillStyle = '#94a3b8';
        ctx.fillRect(p.x, p.y, p.w, 4);
        
        ctx.shadowBlur = 0;

        if (p.type === 'boost') {
            // Draw arrows
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(p.x + p.w/2, p.y + 5);
            ctx.lineTo(p.x + p.w/2 - 10, p.y + 25);
            ctx.lineTo(p.x + p.w/2 + 10, p.y + 25);
            ctx.fill();
        }
    });

    // Gems
    const time = Date.now() / 500;
    gems.forEach(g => {
        const def = gemTypes[g.type];
        const hoverY = Math.sin(time + g.floatOffset) * 5;
        
        ctx.save();
        ctx.translate(g.x + 15, g.y + 15 + hoverY);
        
        // Glow
        ctx.shadowColor = def.color;
        ctx.shadowBlur = 20;
        
        // Shape
        ctx.fillStyle = def.color;
        if (def.border) {
            ctx.strokeStyle = def.border;
            ctx.lineWidth = 2;
        }
        
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(15, 0);
        ctx.lineTo(0, 15);
        ctx.lineTo(-15, 0);
        ctx.closePath();
        ctx.fill();
        if (def.border) ctx.stroke();

        ctx.restore();
    });

    // Player
    ctx.save();
    ctx.translate(player.x + player.w/2, player.y + player.h); // Pivot bottom center
    ctx.rotate(player.rotation);
    ctx.scale(player.squashX, player.squashY);
    
    // Trail effect if fast
    if (Math.abs(player.vx) > 8) {
        ctx.fillStyle = `rgba(59, 130, 246, 0.3)`;
        ctx.fillRect(-player.w/2 - 5, -player.h, player.w, player.h);
    }
    
    // Flight aura
    const flight = player.activeEffects.find(e => e.type === 'black');
    if (flight) {
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 20;
    }

    ctx.fillStyle = player.color;
    ctx.fillRect(-player.w/2, -player.h, player.w, player.h);
    
    // Face
    ctx.fillStyle = '#fff';
    // Eyes
    let eyeOff = player.facingRight ? 4 : -4;
    ctx.fillRect(-player.w/2 + 6 + eyeOff, -player.h + 8, 6, 6);
    ctx.fillRect(-player.w/2 + 18 + eyeOff, -player.h + 8, 6, 6);
    
    ctx.restore();

    // Particles
    drawParticles();

    ctx.restore();
}

/**
 * PARTICLE SYSTEM
 */
function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1.0,
            color: color,
            size: Math.random() * 4 + 2
        });
    }
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        p.size *= 0.95;
        if (p.life <= 0) particles.splice(i, 1);
    }
}

function drawParticles() {
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.rect(p.x, p.y, p.size, p.size);
        ctx.fill();
    });
    ctx.globalAlpha = 1.0;
}

/**
 * MAIN LOOP
 */
function loop(timestamp) {
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    if (gameState === 'PLAYING') {
        update(dt);
    }
    draw();
    requestAnimationFrame(loop);
}

// Start
init();

</script>
</body>
</html>
